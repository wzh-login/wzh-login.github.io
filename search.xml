<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux安装mysql配置</title>
      <link href="2020/04/20/linux-an-zhuang-mysql-pei-zhi/"/>
      <url>2020/04/20/linux-an-zhuang-mysql-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-yum安装mysql"><a href="#1-yum安装mysql" class="headerlink" title="1.yum安装mysql"></a>1.yum安装mysql</h1><h3 id="1-1下载mysql的rpm地址"><a href="#1-1下载mysql的rpm地址" class="headerlink" title="1.1下载mysql的rpm地址"></a>1.1下载mysql的rpm地址</h3><blockquote><p><a href="http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/">http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/</a></p></blockquote><h3 id="1-2-配置mysql扩展源"><a href="#1-2-配置mysql扩展源" class="headerlink" title="1.2 配置mysql扩展源"></a>1.2 配置mysql扩展源</h3><blockquote><p>rpm -ivh  <a href="http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql57-community-release-el7-10.noarch.rpm">http://repo.mysql.com/yum/mysql-5.7-community/el/7/x86_64/mysql57-community-release-el7-10.noarch.rpm</a></p></blockquote><h3 id="1-3-yum安装mysql"><a href="#1-3-yum安装mysql" class="headerlink" title="1-3    yum安装mysql"></a>1-3    yum安装mysql</h3><blockquote><p>yum install mysql-community-server -y</p></blockquote><h3 id="1-4-启动mysql-并加入开机自启"><a href="#1-4-启动mysql-并加入开机自启" class="headerlink" title="1-4 启动mysql,并加入开机自启"></a>1-4 启动mysql,并加入开机自启</h3><blockquote><p>systemctl start mysqld</p><p>systemctl stop mysqld</p><p>systemctl emable mysqld</p></blockquote><h3 id="1-5-使用mysql初始密码登录数据库"><a href="#1-5-使用mysql初始密码登录数据库" class="headerlink" title="1-5 使用mysql初始密码登录数据库"></a>1-5 使用mysql初始密码登录数据库</h3><blockquote><p>grep “password” /var/log/mysqld.log    #查看初始化密码登录</p><p>mysql -uroot -p</p><p>或者一步到位进入mysql</p><p>mysql -uroot -p$(awk ‘/temporary password/(print $NF)’ /var/log/mysqld.log)</p></blockquote><h3 id="1-6-密码降级"><a href="#1-6-密码降级" class="headerlink" title="1-6    密码降级"></a>1-6    密码降级</h3><blockquote><p>set global validate_password_policy=0;  #给密码降级(只数字或者字母就可以)</p><p>set password for root@localgost = password(‘密码’);  #修改密码  </p></blockquote><h3 id="1-7-授权所有用户连接"><a href="#1-7-授权所有用户连接" class="headerlink" title="1-7    授权所有用户连接"></a>1-7    授权所有用户连接</h3><blockquote><p>grant all on <em>.</em> to root@’%’ identified by ‘数据库密码’;</p><p>flush privileges;    #刷新</p></blockquote><h3 id="接下来就可以进行连接了…"><a href="#接下来就可以进行连接了…" class="headerlink" title="接下来就可以进行连接了…"></a>接下来就可以进行连接了…</h3>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch的restful参考文档</title>
      <link href="2020/04/20/elasticsearch-de-restful-can-kao-wen-dang/"/>
      <url>2020/04/20/elasticsearch-de-restful-can-kao-wen-dang/</url>
      
        <content type="html"><![CDATA[<h1 id="ElasticSearch的restful参考文档"><a href="#ElasticSearch的restful参考文档" class="headerlink" title="ElasticSearch的restful参考文档"></a>ElasticSearch的restful参考文档</h1><h1 id="一-索引库"><a href="#一-索引库" class="headerlink" title="一.   索引库"></a>一.   索引库</h1><h2 id="1-1-创建索引库-Create-Indexe"><a href="#1-1-创建索引库-Create-Indexe" class="headerlink" title="1.1.创建索引库 Create Indexe"></a>1.1.创建索引库 Create Indexe</h2><p>创建索引的请求格式：</p><p>请求方式：PUT</p><p>请求路径：/索引库名</p><p>请求参数：json格式：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT &#x2F;heima&#123;    &quot;settings&quot;: &#123;        &quot;属性名&quot;: &quot;属性值&quot;     &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>settings：就是索引库设置，其中可以定义索引库的各种属性，目前我们可以不设置，都走默认。</p><h2 id="1-2、查看索引库-Get-Index"><a href="#1-2、查看索引库-Get-Index" class="headerlink" title="1.2、查看索引库 Get Index"></a>1.2、查看索引库 Get Index</h2><p>请求方式：GET</p><p>请求路径：/索引库名</p><p>语法：GET /索引库名</p><p>示例：</p><p>GET /heima</p><h2 id="1-3、删除索引库-delete-index"><a href="#1-3、删除索引库-delete-index" class="headerlink" title="1.3、删除索引库 delete index"></a>1.3、删除索引库 delete index</h2><p>请求方式：DELETE</p><p>请求路径：/索引库名</p><p>语法：DELETE /索引库名</p><p>示例：</p><p>DELETE /heima</p><h1 id="二-类型及映射操作"><a href="#二-类型及映射操作" class="headerlink" title="二.   类型及映射操作"></a>二.   类型及映射操作</h1><h2 id="2-1、-创建映射关系"><a href="#2-1、-创建映射关系" class="headerlink" title="2.1、 创建映射关系"></a>2.1、 创建映射关系</h2><p>语法：</p> <pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT &#x2F;索引库名&#x2F;_mapping&#x2F;类型名称&#123; &quot;properties&quot;: &#123;   &quot;字段名&quot;: &#123;     &quot;type&quot;: &quot;类型&quot;,     &quot;index&quot;: true，     &quot;store&quot;: true，     &quot;analyzer&quot;: &quot;分词器&quot;   &#125; &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>·       类型名称：就是前面将的type的概念，类似于数据库中的表 字段名：任意填写，下面指定许多属性，例如：</p><ul><li><p> type：类型，可以是text、long、short、date、integer、object等</p></li><li><p>index：是否索引，默认为true</p></li><li><p>store：是否存储，默认为false</p></li><li><p>analyzer：分词器，这里的ik_max_word即使用ik分词器</p></li></ul><p>示例</p><p>发起请求：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT heima&#x2F;_mapping&#x2F;goods&#123; &quot;properties&quot;: &#123;   &quot;title&quot;: &#123;     &quot;type&quot;: &quot;text&quot;,     &quot;analyzer&quot;: &quot;ik_max_word&quot;  &#125;,   &quot;images&quot;: &#123;     &quot;type&quot;: &quot;keyword&quot;,     &quot;index&quot;: &quot;false&quot;  &#125;,   &quot;price&quot;: &#123;     &quot;type&quot;: &quot;float&quot;  &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>响应结果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123; &quot;acknowledged&quot;: true &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述案例中，就给heima这个索引库添加了一个名为goods的类型，并且在类型中设置了3个字段：</p><ul><li><p> title：商品标题</p></li><li><p>images：商品图片</p></li><li><p>price：商品价格</p></li></ul><h2 id="2-2、查看映射关系"><a href="#2-2、查看映射关系" class="headerlink" title="2.2、查看映射关系"></a>2.2、查看映射关系</h2><p>语法：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET &#x2F;索引库名&#x2F;_mapping<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看某个索引库中的所有类型的映射。如果要查看某个类型映射，可以再路径后面跟上类型名称。即：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET &#x2F;索引库名&#x2F;_mapping&#x2F;映射名 或者 GET &#x2F;heima&#x2F;_mapping&#x2F;goods<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET &#x2F;heima&#x2F;_mapping<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>响应：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123; &quot;heima&quot;: &#123;   &quot;mappings&quot;: &#123;     &quot;goods&quot;: &#123;       &quot;properties&quot;: &#123;         &quot;images&quot;: &#123;           &quot;type&quot;: &quot;keyword&quot;,           &quot;index&quot;: false        &#125;,         &quot;price&quot;: &#123;           &quot;type&quot;: &quot;float&quot;        &#125;,         &quot;title&quot;: &#123;           &quot;type&quot;: &quot;text&quot;,           &quot;analyzer&quot;: &quot;ik_max_word&quot;        &#125;      &#125;    &#125;  &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3、一次创建索引库和类型"><a href="#2-3、一次创建索引库和类型" class="headerlink" title="2.3、一次创建索引库和类型"></a>2.3、一次创建索引库和类型</h2><p>基本语法：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">put &#x2F;索引库名&#123;   &quot;settings&quot;:&#123;       &quot;索引库属性名&quot;:&quot;索引库属性值&quot;  &#125;,   &quot;mappings&quot;:&#123;       &quot;类型名&quot;:&#123;           &quot;properties&quot;:&#123;               &quot;字段名&quot;:&#123;                   &quot;映射属性名&quot;:&quot;映射属性值&quot;              &#125;          &#125;      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT &#x2F;heima2&#123; &quot;settings&quot;: &#123;&#125;,  &quot;mappings&quot;: &#123;   &quot;goods&quot;: &#123;     &quot;properties&quot;: &#123;       &quot;title&quot;: &#123;         &quot;type&quot;: &quot;text&quot;,         &quot;analyzer&quot;: &quot;ik_max_word&quot;      &#125;    &#125;  &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三-文档操作"><a href="#三-文档操作" class="headerlink" title="三.   文档操作"></a>三.   文档操作</h1><h2 id="3-1、新增文档"><a href="#3-1、新增文档" class="headerlink" title="3.1、新增文档"></a>3.1、新增文档</h2><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">POST &#x2F;索引库名&#x2F;类型&#x2F;id值&#123;  ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">POST &#x2F;heima&#x2F;goods&#x2F;2&#123;   &quot;title&quot;:&quot;大米手机&quot;,   &quot;images&quot;:&quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;12479122.jpg&quot;,   &quot;price&quot;:2899.00&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者 </p><pre class="line-numbers language-none"><code class="language-none">POST &#x2F;heima&#x2F;goods&#x2F;&#123;   &quot;title&quot;:&quot;小米手机&quot;,   &quot;images&quot;:&quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;12479122.jpg&quot;,   &quot;price&quot;:2699.00&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2、查看文档"><a href="#3-2、查看文档" class="headerlink" title="3.2、查看文档"></a>3.2、查看文档</h2><p>语法：</p><p>GET /heima/goods/2</p><p>查看结果：</p><p>{<br>  “_index”: “heima”,<br>  “_type”: “goods”,<br>  “_id”: “r9c1KGMBIhaxtY5rlRKv”,<br>  “_version”: 1,<br>  “found”: true,<br>  “_source”: {<br>    “title”: “小米手机”,<br>    “images”: “<a href="http://image.leyou.com/12479122.jpg&quot;">http://image.leyou.com/12479122.jpg&quot;</a>,<br>    “price”: 2699<br> }<br> }</p><h2 id="3-3、修改文档"><a href="#3-3、修改文档" class="headerlink" title="3.3、修改文档"></a>3.3、修改文档</h2><p>把新增的请求方式改为PUT，就是修改了。不过修改必须指定id，</p><p>·       id对应文档存在，则修改</p><p>·       id对应文档不存在，则新增</p><p>比如，我们把使用id为3，不存在，则应该是新增：</p><p>PUT /heima/goods/3<br> {<br>    “title”:”超米手机”,<br>    “images”:”<a href="http://image.leyou.com/12479122.jpg&quot;">http://image.leyou.com/12479122.jpg&quot;</a>,<br>    “price”:3899.00,<br>    “stock”: 100,<br>    “saleable”:true<br> }</p><p>我们再次执行刚才的请求，不过把数据改一下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT &#x2F;heima&#x2F;goods&#x2F;3&#123;   &quot;title&quot;:&quot;超大米手机&quot;,   &quot;images&quot;:&quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;12479122.jpg&quot;,   &quot;price&quot;:3299.00,   &quot;stock&quot;: 100,   &quot;saleable&quot;:true&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看结果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123; &quot;_index&quot;: &quot;heima&quot;, &quot;_type&quot;: &quot;goods&quot;, &quot;_id&quot;: &quot;3&quot;, &quot;_version&quot;: 2, &quot;result&quot;: &quot;updated&quot;, &quot;_shards&quot;: &#123;   &quot;total&quot;: 2,   &quot;successful&quot;: 1,   &quot;failed&quot;: 0&#125;, &quot;_seq_no&quot;: 2, &quot;_primary_term&quot;: 1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到结果是：<code>updated</code>，显然是更新数据</p><h2 id="3-4、删除文档"><a href="#3-4、删除文档" class="headerlink" title="3.4、删除文档"></a>3.4、删除文档</h2><p>删除使用DELETE请求，同样，需要根据id进行删除：</p><p>语法</p><pre class="line-numbers language-none"><code class="language-none">DELETE &#x2F;索引库名&#x2F;类型名&#x2F;id值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">DELETE &#x2F;heima&#x2F;goods&#x2F;3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="四-文档查询"><a href="#四-文档查询" class="headerlink" title="四.   文档查询"></a>四.   文档查询</h1><p>基本语法</p><p>GET /索引库名/_search<br> {<br>    “query”:{<br>        “查询类型”:{<br>            “查询条件”:”查询条件值”<br>       }<br>   }<br> }</p><p>这里的query代表一个查询对象，里面可以有不同的查询属性</p><p>·       查询类型：</p><p>o   例如：match_all， match，term ， range 等等</p><h2 id="4-1、查询所有（match-all"><a href="#4-1、查询所有（match-all" class="headerlink" title="4.1、查询所有（match_all)"></a>4.1、查询所有（match_all)</h2><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;heima&#x2F;_search&#123;   &quot;query&quot;:&#123;       &quot;match_all&quot;: &#123;&#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>·       <code>query</code>：代表查询对象</p><p>·       <code>match_all</code>：代表查询所有</p><h2 id="4-2、匹配查询（match"><a href="#4-2、匹配查询（match" class="headerlink" title="4.2、匹配查询（match)"></a>4.2、匹配查询（match)</h2><p><code>match</code>类型查询，会把查询条件进行分词，然后进行查询,多个词条之间是or的关系</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;heima&#x2F;_search&#123;   &quot;query&quot;:&#123;       &quot;match&quot;:&#123;           &quot;title&quot;:&quot;小米电视&quot;      &#125;  &#125;&#125;GET goods&#x2F;_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;all&quot;: &#123;&quot;query&quot;: &quot;oppo手机&quot;,&quot;operator&quot;: &quot;and&quot;&#125;  &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3、词条匹配（term"><a href="#4-3、词条匹配（term" class="headerlink" title="4.3、词条匹配（term)"></a>4.3、词条匹配（term)</h2><p><code>term</code> 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些<strong>未分词</strong>的字符串</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;heima&#x2F;_search&#123;   &quot;query&quot;:&#123;       &quot;term&quot;:&#123;           &quot;price&quot;:2699.00      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4、模糊查询-fuzzy"><a href="#4-4、模糊查询-fuzzy" class="headerlink" title="4.4、模糊查询 (fuzzy)"></a>4.4、模糊查询 (fuzzy)</h2><p>我们新增一个商品：</p><pre class="line-numbers language-none"><code class="language-none">POST &#x2F;heima&#x2F;goods&#x2F;4&#123;   &quot;title&quot;:&quot;apple手机&quot;,   &quot;images&quot;:&quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;12479122.jpg&quot;,   &quot;price&quot;:6899.00&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>fuzzy</code> 查询是 <code>term</code> 查询的模糊等价。它允许用户搜索词条与实际词条的拼写出现偏差，但是偏差的编辑距离不得超过2：</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;heima&#x2F;_search&#123;  &quot;query&quot;: &#123;    &quot;fuzzy&quot;: &#123;      &quot;title&quot;: &quot;appla&quot;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的查询，也能查询到apple手机</p><p>我们可以通过<code>fuzziness</code>来指定允许的编辑距离：</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;heima&#x2F;_search&#123; &quot;query&quot;: &#123;   &quot;fuzzy&quot;: &#123;       &quot;title&quot;: &#123;           &quot;value&quot;:&quot;appla&quot;,           &quot;fuzziness&quot;:1      &#125;  &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-5、范围查询-range"><a href="#4-5、范围查询-range" class="headerlink" title="4.5、范围查询 (range)"></a>4.5、范围查询 (range)</h2><p><code>range</code> 查询找出那些落在指定区间内的数字或者时间</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;heima&#x2F;_search&#123;   &quot;query&quot;:&#123;       &quot;range&quot;: &#123;           &quot;price&quot;: &#123;               &quot;gt&quot;:  1000.0,               &quot;lt&quot;:   2800.00          &#125;  &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>range</code>查询允许以下字符：</p><table><thead><tr><th><strong>操作符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>gt</td><td>大于</td></tr><tr><td>gte</td><td>大于等于</td></tr><tr><td>lt</td><td>小于</td></tr><tr><td>lte</td><td>小于等于</td></tr></tbody></table><h2 id="4-6、布尔组合-bool"><a href="#4-6、布尔组合-bool" class="headerlink" title="4.6、布尔组合 (bool)"></a>4.6、布尔组合 (bool)</h2><p><code>bool</code>把各种其它查询通过<code>must</code>（与）、<code>must_not</code>（非）、<code>should</code>（或）的方式进行组合</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;heima&#x2F;_search&#123;   &quot;query&quot;:&#123;       &quot;bool&quot;:&#123;      &quot;must&quot;:     &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;大米&quot; &#125;&#125;,      &quot;must_not&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;:  &quot;电视&quot; &#125;&#125;,      &quot;should&quot;:   &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;手机&quot; &#125;&#125;,      &quot;filter&quot;:      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-none"><code class="language-none">&#123; &quot;took&quot;: 10, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123;   &quot;total&quot;: 3,   &quot;successful&quot;: 3,   &quot;skipped&quot;: 0,   &quot;failed&quot;: 0&#125;, &quot;hits&quot;: &#123;   &quot;total&quot;: 1,   &quot;max_score&quot;: 0.5753642,   &quot;hits&quot;: [    &#123;       &quot;_index&quot;: &quot;heima&quot;,       &quot;_type&quot;: &quot;goods&quot;,       &quot;_id&quot;: &quot;2&quot;,       &quot;_score&quot;: 0.5753642,       &quot;_source&quot;: &#123;         &quot;title&quot;: &quot;大米手机&quot;,         &quot;images&quot;: &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;12479122.jpg&quot;,         &quot;price&quot;: 2899      &#125;    &#125;  ]&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-7、结果过滤"><a href="#4-7、结果过滤" class="headerlink" title="4.7、结果过滤"></a>4.7、结果过滤</h2><p>默认情况下，elasticsearch在搜索的结果中，会把文档中保存在<code>_source</code>的所有字段都返回。</p><p>如果我们只想获取其中的部分字段，我们可以添加<code>_source</code>的过滤</p><h3 id="4-7-1、直接指定字段"><a href="#4-7-1、直接指定字段" class="headerlink" title="4.7.1、直接指定字段"></a>4.7.1、直接指定字段</h3><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;heima&#x2F;_search&#123; &quot;_source&quot;: [&quot;title&quot;,&quot;price&quot;], &quot;query&quot;: &#123;   &quot;term&quot;: &#123;     &quot;price&quot;: 2699  &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回的结果：</p><pre class="line-numbers language-none"><code class="language-none">&#123; &quot;took&quot;: 12, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123;   &quot;total&quot;: 3,   &quot;successful&quot;: 3,   &quot;skipped&quot;: 0,   &quot;failed&quot;: 0&#125;, &quot;hits&quot;: &#123;   &quot;total&quot;: 1,   &quot;max_score&quot;: 1,   &quot;hits&quot;: [    &#123;       &quot;_index&quot;: &quot;heima&quot;,       &quot;_type&quot;: &quot;goods&quot;,       &quot;_id&quot;: &quot;r9c1KGMBIhaxtY5rlRKv&quot;,       &quot;_score&quot;: 1,       &quot;_source&quot;: &#123;         &quot;price&quot;: 2699,         &quot;title&quot;: &quot;小米手机&quot;      &#125;    &#125;  ]&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-7-2、指定includes和excludes"><a href="#4-7-2、指定includes和excludes" class="headerlink" title="4.7.2、指定includes和excludes"></a>4.7.2、指定includes和excludes</h3><p>我们也可以通过：</p><p>·       includes：来指定想要显示的字段</p><p>·       excludes：来指定不想要显示的字段</p><p>二者都是可选的。</p><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;heima&#x2F;_search&#123; &quot;_source&quot;: &#123;   &quot;includes&quot;:[&quot;title&quot;,&quot;price&quot;]&#125;, &quot;query&quot;: &#123;   &quot;term&quot;: &#123;     &quot;price&quot;: 2699  &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与下面的结果将是一样的：</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;heima&#x2F;_search&#123; &quot;_source&quot;: &#123;    &quot;excludes&quot;: [&quot;images&quot;]&#125;, &quot;query&quot;: &#123;   &quot;term&quot;: &#123;     &quot;price&quot;: 2699  &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-8、查询过滤-filter"><a href="#4-8、查询过滤-filter" class="headerlink" title="4.8、查询过滤(filter)"></a>4.8、查询过滤(filter)</h2><h4 id="4-8-1、条件查询中进行过滤"><a href="#4-8-1、条件查询中进行过滤" class="headerlink" title="4.8.1、条件查询中进行过滤"></a>4.8.1、<strong>条件查询中进行过滤</strong></h4><p>所有的查询都会影响到文档的评分及排名。如果我们需要在查询结果中进行过滤，并且不希望过滤条件影响评分，那么就不要把过滤条件作为查询条件来用。而是使用<code>filter</code>方式：</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;heima&#x2F;_search&#123;   &quot;query&quot;:&#123;       &quot;bool&quot;:&#123;      &quot;must&quot;:&#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;小米手机&quot; &#125;&#125;,      &quot;filter&quot;:&#123;               &quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gt&quot;:2000.00,&quot;lt&quot;:3800.00&#125;&#125;      &#125;      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-8-2、无查询条件，直接过滤"><a href="#4-8-2、无查询条件，直接过滤" class="headerlink" title="4.8.2、无查询条件，直接过滤"></a><strong>4.8.2、无查询条件，直接过滤</strong></h4><p>如果一次查询只有过滤，没有查询条件，不希望进行评分，我们可以使用<code>constant_score</code>取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;heima&#x2F;_search&#123;   &quot;query&quot;:&#123;       &quot;constant_score&quot;:   &#123;           &quot;filter&quot;: &#123;          &quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gt&quot;:2000.00,&quot;lt&quot;:3000.00&#125;&#125;          &#125;      &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-9、排序"><a href="#4-9、排序" class="headerlink" title="4.9、排序"></a>4.9、排序</h2><h3 id="4-9-1、单字段排序"><a href="#4-9-1、单字段排序" class="headerlink" title="4.9.1、单字段排序"></a>4.9.1、单字段排序</h3><p><code>sort</code> 可以让我们按照不同的字段进行排序，并且通过<code>order</code>指定排序的方式</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET &#x2F;heima&#x2F;_search&#123; &quot;query&quot;: &#123;   &quot;match&quot;: &#123;     &quot;title&quot;: &quot;小米手机&quot;  &#125;&#125;, &quot;sort&quot;: [  &#123;     &quot;price&quot;: &#123;       &quot;order&quot;: &quot;desc&quot;    &#125;  &#125;]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-9-2、多字段排序"><a href="#4-9-2、多字段排序" class="headerlink" title="4.9.2、多字段排序"></a>4.9.2、多字段排序</h3><p>假定我们想要结合使用 price和 _score（得分） 进行查询，并且匹配的结果首先按照价格排序，然后按照相关性得分排序：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET &#x2F;heima&#x2F;_search&#123;   &quot;query&quot;:&#123;       &quot;bool&quot;:&#123;      &quot;must&quot;:&#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;小米手机&quot; &#125;&#125;,      &quot;filter&quot;:&#123;               &quot;range&quot;:&#123;&quot;price&quot;:&#123;&quot;gt&quot;:2000,&quot;lt&quot;:3000&#125;&#125;      &#125;      &#125;  &#125;,   &quot;sort&quot;: [    &#123; &quot;price&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125;,    &#123; &quot;_score&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125;  ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-10、分页"><a href="#4-10、分页" class="headerlink" title="4.10、分页"></a>4.10、分页</h2><p>elasticsearch的分页与mysql数据库非常相似，都是指定两个值：</p><p>·       from：开始位置</p><p>·       size：每页大小</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET &#x2F;heima&#x2F;_search&#123;  &quot;query&quot;: &#123;    &quot;match_all&quot;: &#123;&#125;  &#125;,  &quot;sort&quot;: [    &#123;      &quot;price&quot;: &#123;        &quot;order&quot;: &quot;asc&quot;      &#125;    &#125;  ],  &quot;from&quot;: 2,  &quot;size&quot;: 3&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123; &quot;took&quot;: 4, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123;   &quot;total&quot;: 5,   &quot;successful&quot;: 5,   &quot;skipped&quot;: 0,   &quot;failed&quot;: 0&#125;, &quot;hits&quot;: &#123;   &quot;total&quot;: 4,   &quot;max_score&quot;: null,   &quot;hits&quot;: [    &#123;       &quot;_index&quot;: &quot;heima&quot;,       &quot;_type&quot;: &quot;goods&quot;,       &quot;_id&quot;: &quot;4&quot;,       &quot;_score&quot;: null,       &quot;_source&quot;: &#123;         &quot;title&quot;: &quot;小米电视4A&quot;,         &quot;images&quot;: &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;12479122.jpg&quot;,         &quot;price&quot;: 3899      &#125;,       &quot;sort&quot;: [         3899      ]    &#125;  ]&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-11、高亮"><a href="#4-11、高亮" class="headerlink" title="4.11、高亮"></a>4.11、高亮</h2><p>高亮原理：</p><p>·       服务端搜索数据，得到搜索结果</p><p>·       把搜索结果中，搜索关键字都加上约定好的标签</p><p>·       前端页面提前写好标签的CSS样式，即可高亮</p><p>elasticsearch中实现高亮的语法比较简单：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET &#x2F;heima&#x2F;_search&#123; &quot;query&quot;: &#123;   &quot;match&quot;: &#123;     &quot;title&quot;: &quot;手机&quot;  &#125;&#125;, &quot;highlight&quot;: &#123;   &quot;pre_tags&quot;: &quot;&lt;span style&#x3D;&#39;color:red&#39;&gt;&quot;,   &quot;post_tags&quot;: &quot;&lt;&#x2F;span&gt;&quot;,    &quot;fields&quot;: &#123;     &quot;title&quot;: &#123;&#125;  &#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在使用match查询的同时，加上一个highlight属性：</p><p>·       pre_tags：前置标签</p><p>·       post_tags：后置标签</p><p>·       fields：需要高亮的字段</p><p>o   title：这里声明title字段需要高亮，后面可以为这个字段设置特有配置，也可以空</p><p>结果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123; &quot;took&quot;: 8, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123;   &quot;total&quot;: 5,   &quot;successful&quot;: 5,   &quot;skipped&quot;: 0,   &quot;failed&quot;: 0&#125;, &quot;hits&quot;: &#123;   &quot;total&quot;: 3,   &quot;max_score&quot;: 0.2876821,   &quot;hits&quot;: [    &#123;       &quot;_index&quot;: &quot;heima&quot;,       &quot;_type&quot;: &quot;goods&quot;,       &quot;_id&quot;: &quot;2&quot;,       &quot;_score&quot;: 0.2876821,       &quot;_source&quot;: &#123;         &quot;title&quot;: &quot;大米手机&quot;,         &quot;images&quot;: &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;12479122.jpg&quot;,         &quot;price&quot;: 2899      &#125;,       &quot;highlight&quot;: &#123;         &quot;title&quot;: [           &quot;大米&lt;em&gt;手机&lt;&#x2F;em&gt;&quot;        ]      &#125;    &#125;,    &#123;       &quot;_index&quot;: &quot;heima&quot;,       &quot;_type&quot;: &quot;goods&quot;,       &quot;_id&quot;: &quot;JP6xa2kBtq36Pzvxpjaf&quot;,       &quot;_score&quot;: 0.19856805,       &quot;_source&quot;: &#123;         &quot;title&quot;: &quot;小米手机&quot;,         &quot;images&quot;: &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;12479122.jpg&quot;,         &quot;price&quot;: 2699      &#125;,       &quot;highlight&quot;: &#123;         &quot;title&quot;: [           &quot;小米&lt;em&gt;手机&lt;&#x2F;em&gt;&quot;        ]      &#125;    &#125;,    &#123;       &quot;_index&quot;: &quot;heima&quot;,       &quot;_type&quot;: &quot;goods&quot;,       &quot;_id&quot;: &quot;3&quot;,       &quot;_score&quot;: 0.16853254,       &quot;_source&quot;: &#123;         &quot;title&quot;: &quot;超大米手机&quot;,         &quot;images&quot;: &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;12479122.jpg&quot;,         &quot;price&quot;: 3299,         &quot;stock&quot;: 200,         &quot;saleable&quot;: true,         &quot;subTitle&quot;: &quot;哈哈&quot;      &#125;,       &quot;highlight&quot;: &#123;         &quot;title&quot;: [           &quot;超大米&lt;em&gt;手机&lt;&#x2F;em&gt;&quot;        ]      &#125;    &#125;  ]&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五-聚合aggregations"><a href="#五-聚合aggregations" class="headerlink" title="五. 聚合aggregations"></a>五. 聚合aggregations</h1><p>聚合可以让我们极其方便的实现对数据的统计、分析。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p><h2 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h2><p>Elasticsearch中的聚合，包含多种类型，最常用的两种，一个叫<code>桶</code>，一个叫<code>度量</code>：</p><blockquote><p><strong>桶（bucket）</strong></p></blockquote><p>桶的作用，是按照某种方式对数据进行分组，每一组数据在ES中称为一个<code>桶</code>，例如我们根据国籍对人划分，可以得到<code>中国桶</code>、<code>英国桶</code>，<code>日本桶</code>……或者我们按照年龄段对人进行划分：0<del>10,10</del>20,20<del>30,30</del>40等。</p><p>Elasticsearch中提供的划分桶的方式有很多：</p><ul><li>Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组</li><li>Histogram Aggregation：根据数值阶梯分组，与日期类似，需要知道分组的间隔（interval）</li><li>Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组</li><li>Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组</li><li>……</li></ul><p>综上所述，我们发现bucket aggregations 只负责对数据进行分组，并不进行计算，因此往往bucket中往往会嵌套另一种聚合：metrics aggregations即度量</p><blockquote><p><strong>度量（metrics）</strong></p></blockquote><p>分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为<code>度量</code></p><p>比较常用的一些度量聚合方式：</p><ul><li>Avg Aggregation：求平均值</li><li>Max Aggregation：求最大值</li><li>Min Aggregation：求最小值</li><li>Percentiles Aggregation：求百分比</li><li>Stats Aggregation：同时返回avg、max、min、sum、count等</li><li>Sum Aggregation：求和</li><li>Top hits Aggregation：求前几</li><li>Value Count Aggregation：求总数</li><li>……</li></ul><p>为了测试聚合，我们先批量导入一些数据</p><p>创建索引：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT &#x2F;car&#123;  &quot;mappings&quot;: &#123;    &quot;orders&quot;: &#123;      &quot;properties&quot;: &#123;        &quot;color&quot;: &#123;          &quot;type&quot;: &quot;keyword&quot;        &#125;,        &quot;make&quot;: &#123;          &quot;type&quot;: &quot;keyword&quot;        &#125;      &#125;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：在ES中，需要进行聚合、排序、过滤的字段其处理方式比较特殊，因此不能被分词，必须使用<code>keyword</code>或<code>数值类型</code>。这里我们将color和make这两个文字类型的字段设置为keyword类型，这个类型不会被分词，将来就可以参与聚合</p><p>导入数据，这里是采用批处理的API，大家直接复制到kibana运行即可：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST &#x2F;car&#x2F;orders&#x2F;_bulk&#123; &quot;index&quot;: &#123;&#125;&#125;&#123; &quot;price&quot; : 10000, &quot;color&quot; : &quot;红&quot;, &quot;make&quot; : &quot;本田&quot;, &quot;sold&quot; : &quot;2014-10-28&quot; &#125;&#123; &quot;index&quot;: &#123;&#125;&#125;&#123; &quot;price&quot; : 20000, &quot;color&quot; : &quot;红&quot;, &quot;make&quot; : &quot;本田&quot;, &quot;sold&quot; : &quot;2014-11-05&quot; &#125;&#123; &quot;index&quot;: &#123;&#125;&#125;&#123; &quot;price&quot; : 30000, &quot;color&quot; : &quot;绿&quot;, &quot;make&quot; : &quot;福特&quot;, &quot;sold&quot; : &quot;2014-05-18&quot; &#125;&#123; &quot;index&quot;: &#123;&#125;&#125;&#123; &quot;price&quot; : 15000, &quot;color&quot; : &quot;蓝&quot;, &quot;make&quot; : &quot;丰田&quot;, &quot;sold&quot; : &quot;2014-07-02&quot; &#125;&#123; &quot;index&quot;: &#123;&#125;&#125;&#123; &quot;price&quot; : 12000, &quot;color&quot; : &quot;绿&quot;, &quot;make&quot; : &quot;丰田&quot;, &quot;sold&quot; : &quot;2014-08-19&quot; &#125;&#123; &quot;index&quot;: &#123;&#125;&#125;&#123; &quot;price&quot; : 20000, &quot;color&quot; : &quot;红&quot;, &quot;make&quot; : &quot;本田&quot;, &quot;sold&quot; : &quot;2014-11-05&quot; &#125;&#123; &quot;index&quot;: &#123;&#125;&#125;&#123; &quot;price&quot; : 80000, &quot;color&quot; : &quot;红&quot;, &quot;make&quot; : &quot;宝马&quot;, &quot;sold&quot; : &quot;2014-01-01&quot; &#125;&#123; &quot;index&quot;: &#123;&#125;&#125;&#123; &quot;price&quot; : 25000, &quot;color&quot; : &quot;蓝&quot;, &quot;make&quot; : &quot;福特&quot;, &quot;sold&quot; : &quot;2014-02-12&quot; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-2-聚合为桶"><a href="#5-2-聚合为桶" class="headerlink" title="5.2 聚合为桶"></a>5.2 聚合为桶</h2><p>首先，我们按照 汽车的颜色<code>color来</code>划分<code>桶</code>，按照颜色分桶，最好是使用TermAggregation类型，按照颜色的名称来分桶。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET &#x2F;car&#x2F;_search&#123;    &quot;size&quot; : 0,    &quot;aggs&quot; : &#123;         &quot;popular_colors&quot; : &#123;             &quot;terms&quot; : &#123;               &quot;field&quot; : &quot;color&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>size： 查询条数，这里设置为0，因为我们不关心搜索到的数据，只关心聚合结果，提高效率</li><li>aggs：声明这是一个聚合查询，是aggregations的缩写<ul><li>popular_colors：给这次聚合起一个名字，可任意指定。<ul><li>terms：聚合的类型，这里选择terms，是根据词条内容（这里是颜色）划分<ul><li>field：划分桶时依赖的字段</li></ul></li></ul></li></ul></li></ul><p>结果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;took&quot;: 33,  &quot;timed_out&quot;: false,  &quot;_shards&quot;: &#123;    &quot;total&quot;: 5,    &quot;successful&quot;: 5,    &quot;skipped&quot;: 0,    &quot;failed&quot;: 0  &#125;,  &quot;hits&quot;: &#123;    &quot;total&quot;: 8,    &quot;max_score&quot;: 0,    &quot;hits&quot;: []  &#125;,  &quot;aggregations&quot;: &#123;    &quot;popular_colors&quot;: &#123;      &quot;doc_count_error_upper_bound&quot;: 0,      &quot;sum_other_doc_count&quot;: 0,      &quot;buckets&quot;: [        &#123;          &quot;key&quot;: &quot;红&quot;,          &quot;doc_count&quot;: 4        &#125;,        &#123;          &quot;key&quot;: &quot;绿&quot;,          &quot;doc_count&quot;: 2        &#125;,        &#123;          &quot;key&quot;: &quot;蓝&quot;,          &quot;doc_count&quot;: 2        &#125;      ]    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>hits：查询结果为空，因为我们设置了size为0</li><li>aggregations：聚合的结果</li><li>popular_colors：我们定义的聚合名称</li><li>buckets：查找到的桶，每个不同的color字段值都会形成一个桶<ul><li>key：这个桶对应的color字段的值</li><li>doc_count：这个桶中的文档数量</li></ul></li></ul><p>通过聚合的结果我们发现，目前红色的小车比较畅销！</p><h2 id="5-3-桶内度量"><a href="#5-3-桶内度量" class="headerlink" title="5.3 桶内度量"></a>5.3 桶内度量</h2><p>前面的例子告诉我们每个桶里面的文档数量，这很有用。 但通常，我们的应用需要提供更复杂的文档度量。 例如，每种颜色汽车的平均价格是多少？</p><p>因此，我们需要告诉Elasticsearch<code>使用哪个字段</code>，<code>使用何种度量方式</code>进行运算，这些信息要嵌套在<code>桶</code>内，<code>度量</code>的运算会基于<code>桶</code>内的文档进行</p><p>现在，我们为刚刚的聚合结果添加 求价格平均值的度量：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET &#x2F;car&#x2F;_search&#123;    &quot;size&quot; : 0,    &quot;aggs&quot; : &#123;         &quot;popular_colors&quot; : &#123;             &quot;terms&quot; : &#123;               &quot;field&quot; : &quot;color&quot;            &#125;,            &quot;aggs&quot;:&#123;                &quot;avg_price&quot;: &#123;                    &quot;avg&quot;: &#123;                      &quot;field&quot;: &quot;price&quot;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>aggs：我们在上一个aggs(popular_colors)中添加新的aggs。可见度量也是一个聚合</li><li>avg_price：聚合的名称</li><li>avg：度量的类型，这里是求平均值</li><li>field：度量运算的字段</li></ul><p>结果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;took&quot;: 23,  &quot;timed_out&quot;: false,  &quot;_shards&quot;: &#123;    &quot;total&quot;: 5,    &quot;successful&quot;: 5,    &quot;skipped&quot;: 0,    &quot;failed&quot;: 0  &#125;,  &quot;hits&quot;: &#123;    &quot;total&quot;: 8,    &quot;max_score&quot;: 0,    &quot;hits&quot;: []  &#125;,  &quot;aggregations&quot;: &#123;    &quot;popular_colors&quot;: &#123;      &quot;doc_count_error_upper_bound&quot;: 0,      &quot;sum_other_doc_count&quot;: 0,      &quot;buckets&quot;: [        &#123;          &quot;key&quot;: &quot;红&quot;,          &quot;doc_count&quot;: 4,          &quot;avg_price&quot;: &#123;            &quot;value&quot;: 32500          &#125;        &#125;,        &#123;          &quot;key&quot;: &quot;绿&quot;,          &quot;doc_count&quot;: 2,          &quot;avg_price&quot;: &#123;            &quot;value&quot;: 21000          &#125;        &#125;,        &#123;          &quot;key&quot;: &quot;蓝&quot;,          &quot;doc_count&quot;: 2,          &quot;avg_price&quot;: &#123;            &quot;value&quot;: 20000          &#125;        &#125;      ]    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到每个桶中都有自己的<code>avg_price</code>字段，这是度量聚合的结果</p><h2 id="5-4-桶内嵌套桶"><a href="#5-4-桶内嵌套桶" class="headerlink" title="5.4 桶内嵌套桶"></a>5.4 桶内嵌套桶</h2><p>刚刚的案例中，我们在桶内嵌套度量运算。事实上桶不仅可以嵌套运算， 还可以再嵌套其它桶。也就是说在每个分组中，再分更多组。</p><p>比如：我们想统计每种颜色的汽车中，分别属于哪个制造商，按照<code>make</code>字段再进行分桶</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET &#x2F;car&#x2F;_search&#123;    &quot;size&quot; : 0,    &quot;aggs&quot; : &#123;         &quot;popular_colors&quot; : &#123;             &quot;terms&quot; : &#123;               &quot;field&quot; : &quot;color&quot;            &#125;,            &quot;aggs&quot;:&#123;                &quot;avg_price&quot;: &#123;                    &quot;avg&quot;: &#123;                      &quot;field&quot;: &quot;price&quot;                    &#125;                &#125;,                &quot;maker&quot;:&#123;                    &quot;terms&quot;:&#123;                        &quot;field&quot;:&quot;make&quot;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>原来的color桶和avg计算我们不变</li><li>maker：在嵌套的aggs下新添一个桶，叫做maker</li><li>terms：桶的划分类型依然是词条</li><li>filed：这里根据make字段进行划分</li></ul><p>部分结果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;took&quot;: 16,  &quot;timed_out&quot;: false,  &quot;_shards&quot;: &#123;    &quot;total&quot;: 5,    &quot;successful&quot;: 5,    &quot;skipped&quot;: 0,    &quot;failed&quot;: 0  &#125;,  &quot;hits&quot;: &#123;    &quot;total&quot;: 8,    &quot;max_score&quot;: 0,    &quot;hits&quot;: []  &#125;,  &quot;aggregations&quot;: &#123;    &quot;popular_colors&quot;: &#123;      &quot;doc_count_error_upper_bound&quot;: 0,      &quot;sum_other_doc_count&quot;: 0,      &quot;buckets&quot;: [        &#123;          &quot;key&quot;: &quot;红&quot;,          &quot;doc_count&quot;: 4,          &quot;maker&quot;: &#123;            &quot;doc_count_error_upper_bound&quot;: 0,            &quot;sum_other_doc_count&quot;: 0,            &quot;buckets&quot;: [              &#123;                &quot;key&quot;: &quot;本田&quot;,                &quot;doc_count&quot;: 3              &#125;,              &#123;                &quot;key&quot;: &quot;宝马&quot;,                &quot;doc_count&quot;: 1              &#125;            ]          &#125;,          &quot;avg_price&quot;: &#123;            &quot;value&quot;: 32500          &#125;        &#125;,        &#123;          &quot;key&quot;: &quot;绿&quot;,          &quot;doc_count&quot;: 2,          &quot;maker&quot;: &#123;            &quot;doc_count_error_upper_bound&quot;: 0,            &quot;sum_other_doc_count&quot;: 0,            &quot;buckets&quot;: [              &#123;                &quot;key&quot;: &quot;丰田&quot;,                &quot;doc_count&quot;: 1              &#125;,              &#123;                &quot;key&quot;: &quot;福特&quot;,                &quot;doc_count&quot;: 1              &#125;            ]          &#125;,          &quot;avg_price&quot;: &#123;            &quot;value&quot;: 21000          &#125;        &#125;,        &#123;          &quot;key&quot;: &quot;蓝&quot;,          &quot;doc_count&quot;: 2,          &quot;maker&quot;: &#123;            &quot;doc_count_error_upper_bound&quot;: 0,            &quot;sum_other_doc_count&quot;: 0,            &quot;buckets&quot;: [              &#123;                &quot;key&quot;: &quot;丰田&quot;,                &quot;doc_count&quot;: 1              &#125;,              &#123;                &quot;key&quot;: &quot;福特&quot;,                &quot;doc_count&quot;: 1              &#125;            ]          &#125;,          &quot;avg_price&quot;: &#123;            &quot;value&quot;: 20000          &#125;        &#125;      ]    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我们可以看到，新的聚合<code>maker</code>被嵌套在原来每一个<code>color</code>的桶中。</li><li>每个颜色下面都根据 <code>make</code>字段进行了分组</li><li>我们能读取到的信息：<ul><li>红色车共有4辆</li><li>红色车的平均售价是 $32，500 美元。</li><li>其中3辆是 Honda 本田制造，1辆是 BMW 宝马制造。</li></ul></li></ul><h2 id="5-5-划分桶的其它方式"><a href="#5-5-划分桶的其它方式" class="headerlink" title="5.5.划分桶的其它方式"></a>5.5.划分桶的其它方式</h2><p>前面讲了，划分桶的方式有很多，例如：</p><ul><li>Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组</li><li>Histogram Aggregation：根据数值阶梯分组，与日期类似</li><li>Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组</li><li>Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组</li></ul><p>刚刚的案例中，我们采用的是Terms Aggregation，即根据词条划分桶。</p><p>接下来，我们再学习几个比较实用的：</p><h3 id="5-5-1-阶梯分桶Histogram"><a href="#5-5-1-阶梯分桶Histogram" class="headerlink" title="5.5.1.阶梯分桶Histogram"></a>5.5.1.阶梯分桶Histogram</h3><blockquote><p>原理：</p></blockquote><p>histogram是把数值类型的字段，按照一定的阶梯大小进行分组。你需要指定一个阶梯值（interval）来划分阶梯大小。</p><p>举例：</p><p>比如你有价格字段，如果你设定interval的值为200，那么阶梯就会是这样的：</p><p>0，200，400，600，…</p><p>上面列出的是每个阶梯的key，也是区间的启点。</p><p>如果一件商品的价格是450，会落入哪个阶梯区间呢？计算公式如下：</p><pre class="line-numbers language-none"><code class="language-none">bucket_key &#x3D; Math.floor((value - offset) &#x2F; interval) * interval + offset<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>value：就是当前数据的值，本例中是450</p><p>offset：起始偏移量，默认为0</p><p>interval：阶梯间隔，比如200</p><p>因此你得到的key = Math.floor((450 - 0) / 200) * 200 + 0 = 400</p><blockquote><p>操作一下：</p></blockquote><p>比如，我们对汽车的价格进行分组，指定间隔interval为5000：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET &#x2F;cars&#x2F;_search&#123;  &quot;size&quot;:0,  &quot;aggs&quot;:&#123;    &quot;price&quot;:&#123;      &quot;histogram&quot;: &#123;        &quot;field&quot;: &quot;price&quot;,        &quot;interval&quot;: 5000      &#125;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;took&quot;: 21,  &quot;timed_out&quot;: false,  &quot;_shards&quot;: &#123;    &quot;total&quot;: 5,    &quot;successful&quot;: 5,    &quot;skipped&quot;: 0,    &quot;failed&quot;: 0  &#125;,  &quot;hits&quot;: &#123;    &quot;total&quot;: 8,    &quot;max_score&quot;: 0,    &quot;hits&quot;: []  &#125;,  &quot;aggregations&quot;: &#123;    &quot;price&quot;: &#123;      &quot;buckets&quot;: [        &#123;          &quot;key&quot;: 10000,          &quot;doc_count&quot;: 2        &#125;,        &#123;          &quot;key&quot;: 15000,          &quot;doc_count&quot;: 1        &#125;,        &#123;          &quot;key&quot;: 20000,          &quot;doc_count&quot;: 2        &#125;,        &#123;          &quot;key&quot;: 25000,          &quot;doc_count&quot;: 1        &#125;,        &#123;          &quot;key&quot;: 30000,          &quot;doc_count&quot;: 1        &#125;,        &#123;          &quot;key&quot;: 35000,          &quot;doc_count&quot;: 0        &#125;,        &#123;          &quot;key&quot;: 40000,          &quot;doc_count&quot;: 0        &#125;,        &#123;          &quot;key&quot;: 45000,          &quot;doc_count&quot;: 0        &#125;,        &#123;          &quot;key&quot;: 50000,          &quot;doc_count&quot;: 0        &#125;,        &#123;          &quot;key&quot;: 55000,          &quot;doc_count&quot;: 0        &#125;,        &#123;          &quot;key&quot;: 60000,          &quot;doc_count&quot;: 0        &#125;,        &#123;          &quot;key&quot;: 65000,          &quot;doc_count&quot;: 0        &#125;,        &#123;          &quot;key&quot;: 70000,          &quot;doc_count&quot;: 0        &#125;,        &#123;          &quot;key&quot;: 75000,          &quot;doc_count&quot;: 0        &#125;,        &#123;          &quot;key&quot;: 80000,          &quot;doc_count&quot;: 1        &#125;      ]    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会发现，中间有大量的文档数量为0 的桶，看起来很丑。</p><p>我们可以增加一个参数min_doc_count为1，来约束最少文档数量为1，这样文档数量为0的桶会被过滤</p><p>示例：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET &#x2F;cars&#x2F;_search&#123;  &quot;size&quot;:0,  &quot;aggs&quot;:&#123;    &quot;price&quot;:&#123;      &quot;histogram&quot;: &#123;        &quot;field&quot;: &quot;price&quot;,        &quot;interval&quot;: 5000,        &quot;min_doc_count&quot;: 1      &#125;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;took&quot;: 15,  &quot;timed_out&quot;: false,  &quot;_shards&quot;: &#123;    &quot;total&quot;: 5,    &quot;successful&quot;: 5,    &quot;skipped&quot;: 0,    &quot;failed&quot;: 0  &#125;,  &quot;hits&quot;: &#123;    &quot;total&quot;: 8,    &quot;max_score&quot;: 0,    &quot;hits&quot;: []  &#125;,  &quot;aggregations&quot;: &#123;    &quot;price&quot;: &#123;      &quot;buckets&quot;: [        &#123;          &quot;key&quot;: 10000,          &quot;doc_count&quot;: 2        &#125;,        &#123;          &quot;key&quot;: 15000,          &quot;doc_count&quot;: 1        &#125;,        &#123;          &quot;key&quot;: 20000,          &quot;doc_count&quot;: 2        &#125;,        &#123;          &quot;key&quot;: 25000,          &quot;doc_count&quot;: 1        &#125;,        &#123;          &quot;key&quot;: 30000,          &quot;doc_count&quot;: 1        &#125;,        &#123;          &quot;key&quot;: 80000,          &quot;doc_count&quot;: 1        &#125;      ]    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完美，！</p><p>如果你用kibana将结果变为柱形图，会更好看：</p><h3 id="5-5-2-范围分桶range"><a href="#5-5-2-范围分桶range" class="headerlink" title="5.5.2.范围分桶range"></a>5.5.2.范围分桶range</h3><p>范围分桶与阶梯分桶类似，也是把数字按照阶段进行分组，只不过range方式需要你自己指定每一组的起始和结束大小。</p><h1 id="六-springData操作es"><a href="#六-springData操作es" class="headerlink" title="六.springData操作es"></a>六.springData操作es</h1><p> Spring Data的官网：<a href="http://projects.spring.io/spring-data/">http://projects.spring.io/spring-data/</a></p><p>Spring Data 的使命是给各种数据访问提供统一的编程接口，不管是关系型数据库（如MySQL），还是 非关系数据库（如Redis），或者类似Elasticsearch这样的索引数据库。从而简化开发人员的代码，提 高开发效率。</p><h3 id="6-1-配置SpringDataElasticsearch"><a href="#6-1-配置SpringDataElasticsearch" class="headerlink" title="6.1.配置SpringDataElasticsearch"></a>6.1.配置SpringDataElasticsearch</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2在resources下新建application-yml文件，引入elasticsearch的host和port即可"><a href="#6-2在resources下新建application-yml文件，引入elasticsearch的host和port即可" class="headerlink" title="6.2在resources下新建application.yml文件，引入elasticsearch的host和port即可"></a>6.2在resources下新建application.yml文件，引入elasticsearch的host和port即可</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">spring:  data:    elasticsearch:      cluster-name: leyou-elastic  #集群名字      cluster-nodes: 127.0.0.1:9300,127.0.0.1:9302,127.0.0.1:9303 #地址3开头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3创建索引库"><a href="#6-3创建索引库" class="headerlink" title="6.3创建索引库"></a>6.3创建索引库</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 测试SpringDataElasticSearch *&#x2F;@RunWith(SpringRunner.class)@SpringBootTestpublic class TestSpringDataEs &#123;    &#x2F;&#x2F;想要创建索引库    @Autowired    private ElasticsearchTemplate esTemplate;                &#x2F;**     * 创建索引库     *&#x2F;    @Test    public void createIndex()&#123;        boolean index &#x3D; esTemplate.createIndex(Goods.class);        System.out.println(index);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4准备一个新的实体类，作为下面与索引库对应的文档"><a href="#6-4准备一个新的实体类，作为下面与索引库对应的文档" class="headerlink" title="6.4准备一个新的实体类，作为下面与索引库对应的文档"></a>6.4准备一个新的实体类，作为下面与索引库对应的文档</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 商品数据 *&#x2F;@Data@AllArgsConstructor@NoArgsConstructor&#x2F;&#x2F;索引库名字,类型,分片数量@Document(indexName &#x3D; &quot;goods&quot;,type &#x3D; &quot;docs&quot;,shards &#x3D; 3)public class Goods &#123;    &#x2F;**     * 商品的主键id,把原始数据放入es中     * 当前文档的唯一标识Id  _id  的值和这个id内容一样     *&#x2F;    @Id &#x2F;&#x2F;标识当前是唯一标识Id    @Field(type&#x3D; FieldType.Keyword)    private  Long id;    &#x2F;**     * 商品名字     * 需要做全文检索 ，类型Text  ，选择分词器ik_max_word     *&#x2F;    @Field(type &#x3D; FieldType.Text,analyzer &#x3D; &quot;ik_max_word&quot;,fielddata &#x3D; true)    private String title;    &#x2F;**     * 商品分类 ，如 手机、电脑、电视     * 不需要分词，keyWord     *&#x2F;    @Field(type&#x3D; FieldType.Keyword)    private String category;    &#x2F;**     * 商品品牌     * 不需要分析，keyword     *&#x2F;    @Field(type&#x3D; FieldType.Keyword)    private String brand;    &#x2F;**     * 商品价格     *&#x2F;    @Field(type &#x3D; FieldType.Double)    private Double price;    &#x2F;**     * 商品图片     * keyword ，不参与搜索，index&#x3D;false     *&#x2F;    @Field(type&#x3D; FieldType.Keyword,index &#x3D; false)    private String images;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>几个用到的注解：<br>@Document：声明索引库配置 indexName：索引库名称 type：类型名称，默认是“docs” shards：分片数量，默认5 replicas：副本数量，默认1</p><p> @Id：声明实体类的id </p><p>@Field：声明字段属性 type：字段的数据类型 analyzer：指定分词器类型 index：是否创建索引 </p><h3 id="6-5创建索引库"><a href="#6-5创建索引库" class="headerlink" title="6.5创建索引库"></a>6.5创建索引库</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 测试SpringDataElasticSearch *&#x2F;@RunWith(SpringRunner.class)@SpringBootTestpublic class TestSpringDataEs &#123;    &#x2F;&#x2F;想要创建索引库    @Autowired    private ElasticsearchTemplate esTemplate;    &#x2F;**     * 创建索引库     *&#x2F;    @Test    public void createIndex()&#123;        boolean index &#x3D; esTemplate.createIndex(Goods.class);        System.out.println(index);    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-6索引数据的CRUD"><a href="#6-6索引数据的CRUD" class="headerlink" title="6.6索引数据的CRUD"></a>6.6索引数据的CRUD</h3><h6 id="6-6-1创建crud接口"><a href="#6-6-1创建crud接口" class="headerlink" title="6.6.1创建crud接口"></a>6.6.1创建crud接口</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Goods索引库的CRUD * ElasticsearchRepository 提供了基本CRUD *&#x2F;public interface GoodsRepository extends ElasticsearchRepository&lt;Goods,Long&gt; &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="6-6-2创建索引数剧单个"><a href="#6-6-2创建索引数剧单个" class="headerlink" title="6.6.2创建索引数剧单个"></a>6.6.2创建索引数剧单个</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;    引入CRUD的接口    @Autowired    private GoodsRepository repository;&#x2F;** * 添加文档 * id存在就是修改不存在就是创建 *&#x2F;@Testpublic void createDoc()&#123;    Goods goods &#x3D; new Goods(2L,&quot;小米手机9&quot;,&quot;手机&quot;,&quot;小米&quot;,            3599.00,&quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;1231233.jpg&quot;);    repository.save(goods);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>批量</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**   * 批量添加   *&#x2F;  @Test  public void createDocBatch()&#123;      List&lt;Goods&gt; list &#x3D; new ArrayList&lt;&gt;();      list.add(new Goods(1L, &quot;小米手机7&quot;, &quot;手机&quot;, &quot;小米&quot;, 3299.00,              &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;13123.jpg&quot;));      list.add(new Goods(2L, &quot;坚果手机R1&quot;, &quot;手机&quot;, &quot;锤子&quot;, 3699.00,              &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;13123.jpg&quot;));      list.add(new Goods(3L, &quot;华为META10&quot;, &quot;手机&quot;, &quot;华为&quot;, 4499.00,              &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;13123.jpg&quot;));      list.add(new Goods(4L, &quot;小米Mix2S&quot;, &quot;手机&quot;, &quot;小米&quot;, 4299.00,              &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;13123.jpg&quot;));      list.add(new Goods(5L, &quot;荣耀V10&quot;, &quot;手机&quot;, &quot;华为&quot;, 2799.00,              &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;13123.jpg&quot;));      list.add(new Goods(6L, &quot;荣耀V8&quot;, &quot;手机&quot;, &quot;华为&quot;, 1799.00,              &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;13123.jpg&quot;));      list.add(new Goods(7L, &quot;ViVoX20&quot;, &quot;手机&quot;, &quot;Vivo&quot;, 3799.00,              &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;13123.jpg&quot;));      list.add(new Goods(8L, &quot;Oppo F10&quot;, &quot;手机&quot;, &quot;Oppo&quot;, 2399.00,              &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;13123.jpg&quot;));      list.add(new Goods(9L, &quot;苹果 11&quot;, &quot;手机&quot;, &quot;apple&quot;, 4399.00,              &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;13123.jpg&quot;));      list.add(new Goods(10L, &quot;小米 10&quot;, &quot;手机&quot;, &quot;小米&quot;, 3399.00,              &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;13123.jpg&quot;));      list.add(new Goods(11L, &quot;华为P40&quot;, &quot;手机&quot;, &quot;华为&quot;, 4399.00,              &quot;http:&#x2F;&#x2F;image.leyou.com&#x2F;13123.jpg&quot;));      repository.saveAll(list);  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="6-6-3删除"><a href="#6-6-3删除" class="headerlink" title="6.6.3删除"></a>6.6.3删除</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void delteDoc()&#123;    repository.deleteById(2L);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="6-6-4根据id查询"><a href="#6-6-4根据id查询" class="headerlink" title="6.6.4根据id查询"></a>6.6.4根据id查询</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**    * 根据id 查询    *&#x2F;   @Test   public void findDocById()&#123;       Optional&lt;Goods&gt; optional &#x3D; repository.findById(2L);       System.out.println(optional.isPresent());&#x2F;&#x2F;判断是否存在       System.out.println(&quot;goods&#x3D;&#x3D;&quot;+optional.get());&#x2F;&#x2F;获取内容       System.out.println(optional.orElse(null));&#x2F;&#x2F;为空返回null   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询所有</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**    * 查询所有    *&#x2F;   @Test   public void findAll()&#123;       Iterable&lt;Goods&gt; goodsIterable &#x3D; repository.findAll();       for (Goods goods : goodsIterable) &#123;           System.out.println(&quot;goods&#x3D;&quot;+goods);       &#125;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="6-6-5自定义查询"><a href="#6-6-5自定义查询" class="headerlink" title="6.6.5自定义查询"></a>6.6.5自定义查询</h6><p>接口处修改</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Goods索引库的CRUD * ElasticsearchRepository 提供了基本CRUD *&#x2F;public interface GoodsRepository extends ElasticsearchRepository&lt;Goods,Long&gt; &#123;    &#x2F;**     * 查询价格区间     * @param min     * @param max     * @return     * Price:价格     * Between:范围查询     * OrderBy:排序     * Desc:降序     *&#x2F;    List&lt;Goods&gt; findByPriceBetweenOrderByPriceDesc(Double min, Double max);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void findPriceBetween()&#123;    List&lt;Goods&gt; goodsList &#x3D; repository.findByPriceBetweenOrderByPriceDesc(3000d, 5000d);    for (Goods goods : goodsList) &#123;        System.out.println(goods);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义支持一下语法见pdf</p><h6 id="6-6-6分页聚合高亮这些只能使用原生查询"><a href="#6-6-6分页聚合高亮这些只能使用原生查询" class="headerlink" title="6.6.6分页聚合高亮这些只能使用原生查询"></a>6.6.6分页聚合高亮这些只能使用原生查询</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">    @Test    public void testQueryBuilder()&#123;&#x2F;&#x2F;        创建原生查询构建器        NativeSearchQueryBuilder queryBuilder &#x3D; new NativeSearchQueryBuilder();&#x2F;&#x2F;        设置返回字段        queryBuilder.                withSourceFilter(new FetchSourceFilter(new String[]&#123;&quot;id&quot;,&quot;title&quot;,&quot;price&quot;&#125;,null));&#x2F;&#x2F;        设置关键词查询条件        queryBuilder.withQuery(QueryBuilders.matchQuery(&quot;title&quot;,&quot;小米&quot;).operator(Operator.AND));&#x2F;&#x2F;        设置分页内容        int page &#x3D; 0;        int size &#x3D; 3;        Pageable pageable &#x3D; PageRequest.of(page,size, Sort.by(Sort.Order.desc(&quot;price&quot;)));        queryBuilder.withPageable(pageable);&#x2F;&#x2F;        设置聚合条件&#x2F;&#x2F;        queryBuilder.addAggregation(AggregationBuilders.terms(&quot;brandAggs&quot;).field(&quot;brand&quot;));        &#x2F;&#x2F;高亮显示        queryBuilder.withHighlightFields(new HighlightBuilder.Field(&quot;title&quot;));&#x2F;&#x2F;        把查询的内容发送到es服务端,要查哪个索引，type&#x2F;&#x2F;        AggregatedPage&lt;Goods&gt; aggregatedPage &#x3D; esTemplate.queryForPage(queryBuilder.build(), Goods.class);        SearchResultMapperImpl searchResultMapper &#x3D; new SearchResultMapperImpl();        AggregatedPage&lt;Goods&gt; aggregatedPage &#x3D; esTemplate.queryForPage(queryBuilder.build(), Goods.class,searchResultMapper);&#x2F;&#x2F;        获取搜索的结果        List&lt;Goods&gt; goodsList &#x3D; aggregatedPage.getContent();&#x2F;&#x2F;        获取搜索的结果总数        long total &#x3D; aggregatedPage.getTotalElements();&#x2F;&#x2F;        获取搜索结果的总页数        int totalPages &#x3D; aggregatedPage.getTotalPages();        System.out.println(&quot;total&#x3D;&quot;+total);        System.out.println(&quot;totalPages&#x3D;&quot;+totalPages);        for (Goods goods : goodsList) &#123;            System.out.println(&quot;goods&#x3D;&quot;+goods);            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#125;        System.out.println(&quot;##########聚合###########&quot;);&#x2F;&#x2F;        获取聚合对象&#x2F;&#x2F;        Aggregations aggregations &#x3D; aggregatedPage.getAggregations();&#x2F;&#x2F;&#x2F;&#x2F;        根据名字获取聚合结果&#x2F;&#x2F;        StringTerms terms &#x3D; aggregations.get(&quot;brandAggs&quot;);&#x2F;&#x2F;&#x2F;&#x2F;        从terms中获取buckets&#x2F;&#x2F;        List&lt;? extends Terms.Bucket&gt; buckets &#x3D; terms.getBuckets();&#x2F;&#x2F;        for (Terms.Bucket bucket : buckets) &#123;&#x2F;&#x2F;            String key &#x3D; bucket.getKeyAsString();&#x2F;&#x2F;            System.out.println(&quot;key&#x3D;&#x3D;&quot;+key);&#x2F;&#x2F;            long docCount &#x3D; bucket.getDocCount();&#x2F;&#x2F;            System.out.println(&quot;docCount&#x3D;&#x3D;&quot;+docCount);&#x2F;&#x2F;        &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持高亮需要，必须自定义结果处理器来实现，结果处理器是一个接口(创建在pojo包下)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.google.gson.Gson;import org.apache.commons.beanutils.BeanUtils;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.common.text.Text;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.aggregations.Aggregations;import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;import org.json.JSONObject;import org.springframework.data.domain.Pageable;import org.springframework.data.elasticsearch.core.SearchResultMapper;import org.springframework.data.elasticsearch.core.aggregation.AggregatedPage;import org.springframework.data.elasticsearch.core.aggregation.impl.AggregatedPageImpl;import java.util.ArrayList;import java.util.List;import java.util.Map;public class SearchResultMapperImpl implements SearchResultMapper &#123;    @Override    public &lt;T&gt; AggregatedPage&lt;T&gt; mapResults(SearchResponse response,                                            Class&lt;T&gt; clazz, Pageable pageable) &#123;        long total &#x3D; response.getHits().getTotalHits(); &#x2F;&#x2F;返回时需要的参数        Aggregations aggregations &#x3D; response.getAggregations(); &#x2F;&#x2F;返回时需要的参数        String scrollId &#x3D; response.getScrollId(); &#x2F;&#x2F;返回时需要的参数        float maxScore &#x3D; response.getHits().getMaxScore(); &#x2F;&#x2F;返回时需要的参数&#x2F;&#x2F; 处理我们想要的高亮结果        SearchHit[] hits &#x3D; response.getHits().getHits();        System.out.println(&quot;hits&#x3D;&quot;+hits);        Gson gson &#x3D; new Gson();        List&lt;T&gt; content &#x3D; new ArrayList&lt;&gt;();        &#123;            for (SearchHit hit : hits) &#123;            String jsonString &#x3D; hit.getSourceAsString();            System.out.println(&quot;jsonString&#x3D;&quot;+jsonString);            T t &#x3D; gson.fromJson(jsonString, clazz);            Map&lt;String, HighlightField&gt; highlightFields &#x3D;                    hit.getHighlightFields();            HighlightField highlightField &#x3D; highlightFields.get(&quot;title&quot;);            Text[] fragments &#x3D; highlightField.getFragments();            if(fragments!&#x3D;null&amp;&amp;fragments.length&gt;0)&#123;                String title &#x3D; fragments[0].toString();                try &#123;&#x2F;&#x2F; 把T对象中的 “title”属性的值替换成 title                    BeanUtils.copyProperty(t,&quot;title&quot;,title);                    &#x2F;&#x2F;t.setTitle(title);                &#125; catch (Exception e) &#123;                        e.printStackTrace();                    System.out.println(&quot;SSSSSSSS&quot;);                &#125;            &#125;            content.add(t);        &#125;        return new AggregatedPageImpl&lt;T&gt;(content, pageable, total,                    aggregations, scrollId, maxScore);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> SpringData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改npm安装的全局路径和配置环境变量的坑</title>
      <link href="2020/04/18/xiu-gai-npm-an-zhuang-de-quan-ju-lu-jing-he-pei-zhi-huan-jing-bian-liang-de-keng/"/>
      <url>2020/04/18/xiu-gai-npm-an-zhuang-de-quan-ju-lu-jing-he-pei-zhi-huan-jing-bian-liang-de-keng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>修改了npm包下载默认目录是c盘,将路径改变造成很多包无法使用(报错xxx模块不是内部命令)</p></blockquote><p>步骤如下：</p><h2 id="1-目录创建"><a href="#1-目录创建" class="headerlink" title="1.目录创建"></a>1.目录创建</h2><p>要在你需要存放模块的文件夹里建两个文件夹我是在node目录下建了两个文件夹分别叫node_global和node_cache。</p><h2 id="2-修改路径"><a href="#2-修改路径" class="headerlink" title="2.修改路径"></a>2.修改路径</h2><p>修改npm文件夹下的npmrc文件，打开修改里面的内容，原来的内容删掉，写入<br>prefix=D:\node\node_global<br>cache=D:\node\node_cache<br>这个是配置安装模块的路径为步骤一新建的文件夹。然后可以随便找个模块安装一下。模块就会出现在node_global文件夹里面</p><h2 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3.配置环境变量"></a>3.配置环境变量</h2><p>当安装完模块后还不能用，因为改变了默认的路径，需要修改系统的环境变量配置去让命令行识别命令，这里分为用户变量和系统变量。先在用户变量里面新建明为PATH的变量，值为D:\node\node_global,这个值是你在步骤一种新建的文件夹的路径。然后在系统变量里面新建一个叫NODE_PATH的变量，值为D:\node\node_global\node_modules，这个值是步骤一中新建的node_global下的node_modules文件夹的路径，以后安装的全局模块就在这里，（这个文件夹是安装完任何一个模块后才会出现，所以配置环境变量前要随便先安装一个模块）</p><h2 id="4-更换镜像"><a href="#4-更换镜像" class="headerlink" title="4.更换镜像"></a>4.更换镜像</h2><p>最后关于cnpm我现在是不想用它了之前用它遇到过安装不成功的，现在换了默认地址安装完它后愣是不能使用，所幸还有其他办法，很简单一句话：npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> 这句话就可以设置npm也是从国内淘宝镜像来下载安装模块了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>第三步中为什么要设置用户变量呢？我后来发现这个路径下有一个文件叫XXX.cmd就是你之前安装的模块的名字+cmd，这个cmd文件应该是让用户输入模块名字后能识别的不至于出现XX不是内部命令，我试了一下故意设置错用户的path然后就提示不是内部命令了，那个node_path应该是让node程序自己找模块时识别的。以上全部都是我自己的个人理解，仅供参考，不一定对大家都有用，因为我参考别人的就对我不太管用。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门</title>
      <link href="2020/03/18/docker/"/>
      <url>2020/03/18/docker/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从docker基础到docker-compose容器编排通俗易懂~</p></blockquote><h1 id="Docker笔记"><a href="#Docker笔记" class="headerlink" title="Docker笔记"></a>Docker笔记</h1><h3 id="Docker能干什么"><a href="#Docker能干什么" class="headerlink" title="Docker能干什么?"></a>Docker能干什么?</h3><p>传统虚拟机方式</p><ol><li>资源占用多</li><li>冗余步骤多</li><li>启动慢!</li></ol><p>容器化技术</p><ol><li>传统虚拟机,虚拟出一条硬件,运行完整的操作系统,然后在这个系统上安装和运行软件</li><li>容器内的应用直接运行在宿主机的内容,容器是木有自己的内核的,也没有虚拟我们的硬件,所以就轻便了</li><li>买个容器间是相互隔离的.每个容器内部都有一个属于自己的文件系统,互不影响</li></ol><h5 id="DevOps-开发-运维"><a href="#DevOps-开发-运维" class="headerlink" title="DevOps(开发,运维)"></a>DevOps(开发,运维)</h5><p>应用更快速的交付和部署</p><ul><li>docker打包镜像发布测试,一键运行</li></ul><p>更便捷的升级和扩展</p><ul><li>项目直接打成一个镜像,扩展服务器A!服务器B</li></ul><p>更简单的系统运维</p><ul><li>在容器化之后,我们的开发,测试环境都是高度一致的</li></ul><p>更高效的计算机资源利用</p><ul><li>Docker是内核级别的虚拟化,可以在一个物理机上运行很多的容器实例!服务器的性能可以被压榨到极致.</li></ul><h5 id="Docker的基本组成-名词概念"><a href="#Docker的基本组成-名词概念" class="headerlink" title="Docker的基本组成(名词概念)"></a>Docker的基本组成(名词概念)</h5><p><img src="/2020/03/18/docker/image-20210312103435841.png" alt="image-20210312103435841"></p><p>镜像(image)</p><ul><li>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像===&gt;run ==&gt; tomcat01容器(提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的)。</li></ul><p>容器(container)</p><ul><li>Docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的。启动，停止，删除，基本命令!</li></ul><p>仓库(repository)</p><ul><li>阿里云…..都有容器服务器（配置镜像加速!)</li></ul><h5 id="Run的流程和Docker原理"><a href="#Run的流程和Docker原理" class="headerlink" title="Run的流程和Docker原理"></a>Run的流程和Docker原理</h5><p><img src="/2020/03/18/docker/image-20210312103423885.png" alt="image-20210312103423885"></p><p>底层原理</p><p>Docker是什么工作的?</p><ul><li> Docker是一个 Client - Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问!DockerServer接收到Docker-Client的指令，就会执行这个命令!</li></ul><p><img src="/2020/03/18/docker/image-20210312103407454.png" alt="image-20210312103407454"></p><p>Docker为什么比VM快?</p><ol><li>Docker有着比虚拟机更少的抽象层</li><li>Docekr利用的是宿主机的内核,vm需要的是Cuest OS</li></ol><p>所以说，新建一个容器的时候，docker不需要想虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS,分钟级别的，而docker是利用宿主机的操作系统吗，省略了这个复杂的过程，秒级!</p><h3 id="Docker安装卸载"><a href="#Docker安装卸载" class="headerlink" title="Docker安装卸载"></a>Docker安装卸载</h3><h6 id="1-卸载"><a href="#1-卸载" class="headerlink" title="1.卸载"></a>1.卸载</h6><pre class="line-numbers language-none"><code class="language-none">systemctl stop dockeryum -y remove docker-ce docker-ce-cli containerd.iorm -rf &#x2F;var&#x2F;lib&#x2F;docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-yum安装gcc相关环境-需要确保虚拟机可以上网"><a href="#2-yum安装gcc相关环境-需要确保虚拟机可以上网" class="headerlink" title="2.yum安装gcc相关环境(需要确保虚拟机可以上网)"></a>2.yum安装gcc相关环境(需要确保虚拟机可以上网)</h6><pre class="line-numbers language-none"><code class="language-none">yum -y install gccyum -y install gcc-c++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="3-卸载旧版本"><a href="#3-卸载旧版本" class="headerlink" title="3.卸载旧版本"></a>3.卸载旧版本</h6><pre class="line-numbers language-none"><code class="language-none">sudo yum remove docker \                 docker-client \                 docker-client-latest \                 docker-common \                 docker-latest \                 docker-latest-logrotate \                 docker-logrotate \                 docker-engine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="4-安装需要的软件包"><a href="#4-安装需要的软件包" class="headerlink" title="4,安装需要的软件包"></a>4,安装需要的软件包</h6><pre class="line-numbers language-none"><code class="language-none">yum install -y yum-utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="5-设置镜像仓库"><a href="#5-设置镜像仓库" class="headerlink" title="5.设置镜像仓库"></a>5.设置镜像仓库</h6><pre class="line-numbers language-none"><code class="language-none">yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不好使就用这个</p><pre class="line-numbers language-none"><code class="language-none">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repoyum makecache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="6-更新yum包索引"><a href="#6-更新yum包索引" class="headerlink" title="6.更新yum包索引"></a>6.更新yum包索引</h6><pre class="line-numbers language-none"><code class="language-none">yum makecache fast<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="7-安装Docker-CE"><a href="#7-安装Docker-CE" class="headerlink" title="7.安装Docker CE"></a>7.安装Docker CE</h6><pre class="line-numbers language-none"><code class="language-none">yum install docker-ce docker-ce-cli containerd.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="8-启动Docker测试"><a href="#8-启动Docker测试" class="headerlink" title="8.启动Docker测试"></a>8.启动Docker测试</h6><pre class="line-numbers language-none"><code class="language-none">systemctl start dockerdocker versiondocker run hell-world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>报错正在尝试其他镜像</p><blockquote><pre class="line-numbers language-none"><code class="language-none">&gt;yum clean all&gt;rpm --rebuilddb&gt;地址:https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_34872748&#x2F;article&#x2F;details&#x2F;86571130<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h3><blockquote><p>docker rm -f $(docker ps -a -q)   </p><p>docker rm -f $(docker images -qa)</p></blockquote><p><img src="/2020/03/18/docker/image-20210315135716768.png" alt="image-20210315135716768"></p><p><img src="/2020/03/18/docker/image-20210312111712735.png" alt="image-20210312111712735"></p><h6 id="mysql挂载命令"><a href="#mysql挂载命令" class="headerlink" title="mysql挂载命令"></a>mysql挂载命令</h6><pre class="line-numbers language-none"><code class="language-none">docker run -p 3737:3306 -v &#x2F;home&#x2F;guli&#x2F;resources&#x2F;mysql&#x2F;database:&#x2F;var&#x2F;lib&#x2F;mysql -v &#x2F;home&#x2F;guli&#x2F;resources&#x2F;mysql&#x2F;conf&#x2F;my.cnf:&#x2F;etc&#x2F;my.cnf -v &#x2F;home&#x2F;guli&#x2F;resources&#x2F;mysql:&#x2F;docker-entrypoint-initdb.d -e MYSQL_ROOT_PASSWORD&#x3D;root  --name mysql_guli mysql:5.7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>帮助命令</p><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker">docker version     #显示Docker的版本信息docker info        #显示docker的系统信息,包括和容器,镜像的数量docker 命令 --help   #帮助命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h6 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h6><p>docker images #查看所有本地的主机上的镜像</p><p><img src="/2020/03/18/docker/image-20210312105359238.png" alt="image-20210312105359238"></p><p>docker search 搜索镜像</p><p>docker pull 下载镜像:版本</p><p><img src="/2020/03/18/docker/image-20210312111154086.png" alt="image-20210312111154086"></p><p>docker rmi -f  删除镜像</p><p><img src="/2020/03/18/docker/image-20210312111328425.png" alt="image-20210312111328425"></p><h6 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h6><p><img src="/2020/03/18/docker/image-20210312112249189.png" alt="image-20210312112249189"></p><p><img src="/2020/03/18/docker/image-20210312113644044.png" alt="image-20210312113644044"></p><h6 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h6><p><img src="/2020/03/18/docker/image-20210312152822212.png" alt="image-20210312152822212"></p><p><img src="/2020/03/18/docker/image-20210312154026775.png" alt="image-20210312154026775"></p><p><img src="/2020/03/18/docker/image-20210312154212471.png" alt="image-20210312154212471"></p><h3 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h3><p><img src="/2020/03/18/docker/image-20210312160018942.png" alt="image-20210312160018942"></p><h3 id="Docker镜像讲解"><a href="#Docker镜像讲解" class="headerlink" title="Docker镜像讲解"></a>Docker镜像讲解</h3><p><img src="/2020/03/18/docker/image-20210312160430588.png" alt="image-20210312160430588"></p><p><img src="/2020/03/18/docker/image-20210312160526200.png" alt="image-20210312160526200"></p><p>下载时一层一层的就是这个镜像加载原理</p><p><img src="/2020/03/18/docker/image-20210312160645632.png" alt="image-20210312160645632"></p><h6 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h6><p><img src="/2020/03/18/docker/image-20210312162220697.png" alt="image-20210312162220697"></p><h6 id="如何提交一个自己的镜像commit镜像"><a href="#如何提交一个自己的镜像commit镜像" class="headerlink" title="如何提交一个自己的镜像commit镜像"></a>如何提交一个自己的镜像commit镜像</h6><p><img src="/2020/03/18/docker/image-20210312163212571.png" alt="image-20210312163212571"></p><h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><p><img src="/2020/03/18/docker/image-20210312171402379.png" alt="image-20210312171402379"></p><p><img src="/2020/03/18/docker/image-20210312171447997.png" alt="image-20210312171447997"></p><p><img src="/2020/03/18/docker/image-20210312171506067.png" alt="image-20210312171506067"></p><p><img src="/2020/03/18/docker/image-20210312174930409.png" alt="image-20210312174930409"><img src="/2020/03/18/docker/image-20210313090827893.png" alt="image-20210313090827893"></p><h6 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h6><p><img src="/2020/03/18/docker/image-20210313090812162.png" alt="image-20210313090812162"></p><pre class="line-numbers language-dokcer" data-language="dokcer"><code class="language-dokcer">docker run -p 3306:3306 --name mysql \-v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql \-v &#x2F;mydata&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \-v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql \-e MYSQL_ROOT_PASSWORD&#x3D;root \-d mysql:5.7其中-p 3306:3306 为端口映射， 把容器中的3306映射到宿主机的3306端口中--name mysql 为给容器起个名叫做 mysql&#x2F;var&#x2F;log&#x2F;mysql  和 &#x2F;etc&#x2F;mysql 为mysql 容器内的日志和配置目录 &#x2F;var&#x2F;lib&#x2F;mysql 为容器内mysql的数据。如下的三条命令， 分别为进行宿主机的挂载 。 -v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql \-v &#x2F;mydata&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \-v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql \-e MYSQL_ROOT_PASSWORD&#x3D;root 为给root用户的密码为root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="具名挂载匿名挂载指定路径挂载"><a href="#具名挂载匿名挂载指定路径挂载" class="headerlink" title="具名挂载匿名挂载指定路径挂载"></a>具名挂载匿名挂载指定路径挂载</h6><p><img src="/2020/03/18/docker/image-20210313092737224.png" alt="image-20210313092737224"></p><h6 id="初识DockerFile"><a href="#初识DockerFile" class="headerlink" title="初识DockerFile"></a>初识DockerFile</h6><p>dockerfile 就是来构件docekr镜像的构件文件!命令脚本!先体验一下!</p><p>通过这个脚本可以生成镜像,镜像是一层一层的,脚本一个个的命令,每个命令都是一层!</p><p><img src="/2020/03/18/docker/image-20210313095515210.png" alt="image-20210313095515210"></p><p><img src="/2020/03/18/docker/image-20210313100122880.png" alt="image-20210313100122880"></p><p><img src="/2020/03/18/docker/image-20210313100135788.png" alt="image-20210313100135788"></p><p><img src="/2020/03/18/docker/image-20210313100457699.png" alt="image-20210313100457699"></p><h6 id="数据卷容器同步数据"><a href="#数据卷容器同步数据" class="headerlink" title="数据卷容器同步数据"></a>数据卷容器同步数据</h6><p><img src="/2020/03/18/docker/image-20210313143854561.png" alt="image-20210313143854561"></p><h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><h5 id="DockerFile介绍"><a href="#DockerFile介绍" class="headerlink" title="DockerFile介绍"></a>DockerFile介绍</h5><p><img src="/2020/03/18/docker/image-20210313144618044.png" alt="image-20210313144618044"></p><h5 id="DockerFile构件过程"><a href="#DockerFile构件过程" class="headerlink" title="DockerFile构件过程"></a>DockerFile构件过程</h5><p><img src="/2020/03/18/docker/image-20210313144930670.png" alt="image-20210313144930670"></p><p><img src="/2020/03/18/docker/image-20210313145203744.png" alt="image-20210313145203744"></p><h5 id="DockerFile指令说明"><a href="#DockerFile指令说明" class="headerlink" title="DockerFile指令说明"></a>DockerFile指令说明</h5><p><img src="/2020/03/18/docker/image-20210313145802474.png" alt="image-20210313145802474"></p><p><img src="/2020/03/18/docker/image-20210313145808111.png" alt="image-20210313145808111"></p><h6 id="创建一个自己的centos"><a href="#创建一个自己的centos" class="headerlink" title="创建一个自己的centos"></a>创建一个自己的centos</h6><pre class="line-numbers language-none"><code class="language-none">#1.编写Dockerfile的文件[root@aubin dockerfile]# vim mydockerfile [root@aubin dockerfile]# cat mydockerfile FROM centosMAINTAINER wangzhongheng&lt;2218288230@qq.com&gt;ENV MYPATH &#x2F;usr&#x2F;localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD ECHO $MYPATHCMD ECHO &quot;------end----&quot;CMD &#x2F;bin&#x2F;bash#2.通过这个文件构件镜像#命令: docker build -f mydockerfile -t mycentos:0.1 .#构件成功Successfully built b2b283491cf2Successfully tagged mycentos:0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试运行</p><p><img src="/2020/03/18/docker/image-20210313153902011.png" alt="image-20210313153902011"></p><h6 id="可以查看镜像更改历史-history"><a href="#可以查看镜像更改历史-history" class="headerlink" title="可以查看镜像更改历史(history)"></a>可以查看镜像更改历史(history)</h6><p><img src="/2020/03/18/docker/image-20210313153954220.png" alt="image-20210313153954220"></p><h6 id="CMD和ENTRYPOINT区别"><a href="#CMD和ENTRYPOINT区别" class="headerlink" title="CMD和ENTRYPOINT区别"></a>CMD和ENTRYPOINT区别</h6><p><img src="/2020/03/18/docker/image-20210313154805906.png" alt="image-20210313154805906"></p><p><img src="/2020/03/18/docker/image-20210313155141665.png" alt="image-20210313155141665"></p><p><img src="/2020/03/18/docker/image-20210313155226323.png" alt="image-20210313155226323"></p><p>总结:如果可以追加命令在后面就是ENTPYPOINT实现的镜像</p><h6 id="DockerFile实现制作Tomcat镜像"><a href="#DockerFile实现制作Tomcat镜像" class="headerlink" title="DockerFile实现制作Tomcat镜像"></a>DockerFile实现制作Tomcat镜像</h6><p>1.准备压缩包</p><p><img src="/2020/03/18/docker/image-20210313161936250.png" alt="image-20210313161936250"></p><p>2.编写Dockerfile文件,官方命名’Dockerfile’,build会自动寻找这个文件,就不需要-f指定了!</p><pre class="line-numbers language-none"><code class="language-none">FROM centosMAINTAINER wangzhongheng&lt;2218288230@qq.com&gt;COPY readme.txt &#x2F;usr&#x2F;local&#x2F;readme.txtADD jdk-8u221-linux-x64.tar.gzADD apache-tomcat-9.0.44.tar.gzRUN yum -y install vimENV MYPATH &#x2F;usr&#x2F;localWORKDIR $MYPATHENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;jdk1.8.0.11ENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jarENV CATALINA_HOME &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.44ENV CATALINA_BASH &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.44ENV PATH $PATH:$JAVA_HOME&#x2F;bin:$CATALINA_HOME&#x2F;lib:$CATALINA_HOME&#x2F;binEXPOSE 8080CMD &#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.44&#x2F;bin&#x2F;startup.sh &amp;&amp; tail -F &#x2F;url&#x2F;local&#x2F;apache-tomcat-9.0.44&#x2F;bin&#x2F;logs&#x2F;catalina.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.构件命令</p><pre class="line-numbers language-none"><code class="language-none">docker build -t diytomcat .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.启动挂载日志和项目到本地</p><pre class="line-numbers language-none"><code class="language-none">docker run -d -p 9090:8080 --name wangzhonghengtomcat -v&#x2F;home&#x2F;wangzhongheng&#x2F;build&#x2F;tomcat&#x2F;test:&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.44&#x2F;webapps&#x2F;test -v &#x2F;home&#x2F;wangzhongheng&#x2F;build&#x2F;tomcat&#x2F;tomcatlogs&#x2F;:&#x2F;usr&#x2F;local&#x2F;apache-tomcat-9.0.44&#x2F;logs diytomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5.访问测试</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="/2020/03/18/docker/image-20210315141535584.png" alt="image-20210315141535584"></p><p><img src="/2020/03/18/docker/image-20210315101842969.png" alt="image-20210315101842969"></p><h3 id="springboot发布镜像测试"><a href="#springboot发布镜像测试" class="headerlink" title="springboot发布镜像测试"></a>springboot发布镜像测试</h3><p><img src="/2020/03/18/docker/image-20210315113720221.png" alt="image-20210315113720221"></p><p>dockerfile</p><pre class="line-numbers language-none"><code class="language-none">FROM java:8COPY *.jar &#x2F;app.jarCMD [&quot;--server.port&#x3D;8081&quot;]EXPOSE 8081ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]#构建docker build -t wzh666 .#运行 docker run -d -p 8081:8080 --name wzh-boot-web  wzh666 .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DockerFile网络"><a href="#DockerFile网络" class="headerlink" title="DockerFile网络"></a>DockerFile网络</h3><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><h4 id="Docker-Compose介绍"><a href="#Docker-Compose介绍" class="headerlink" title="Docker Compose介绍"></a>Docker Compose介绍</h4><p><img src="/2020/03/18/docker/image-20210315142131364.png" alt="image-20210315142131364"></p><p><img src="/2020/03/18/docker/image-20210315142531048.png" alt="image-20210315142531048"></p><blockquote><p>个人理解</p></blockquote><p><img src="/2020/03/18/docker/image-20210315143215966.png" alt="image-20210315143215966"></p><h4 id="Docker-Compose安装"><a href="#Docker-Compose安装" class="headerlink" title="Docker Compose安装"></a>Docker Compose安装</h4><p>1.下载</p><pre class="line-numbers language-none"><code class="language-none">sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.28.5&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose#国内curl -L https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.24.0&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2.授权</p><pre class="line-numbers language-none"><code class="language-none">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.测试</p><pre class="line-numbers language-none"><code class="language-none">docker-compose --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.删除</p><pre class="line-numbers language-none"><code class="language-none">sudo rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h4><blockquote><p>官网体验:<a href="https://docs.docker.com/compose/gettingstarted/">https://docs.docker.com/compose/gettingstarted/</a></p></blockquote><p><img src="/2020/03/18/docker/image-20210315150149492.png" alt="image-20210315150149492"></p><p><img src="/2020/03/18/docker/image-20210315160431941.png" alt="image-20210315160431941"></p><p><img src="/2020/03/18/docker/image-20210315161413840.png" alt="image-20210315161413840"></p><p>小结</p><p><img src="/2020/03/18/docker/image-20210315161703725.png" alt="image-20210315161703725"></p><h4 id="yuml编写"><a href="#yuml编写" class="headerlink" title="yuml编写"></a>yuml编写</h4><blockquote><p>官网地址:<a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p></blockquote><p>yuml分为三层</p><blockquote><pre class="line-numbers language-none"><code class="language-none">&gt;version: &quot;3.9&quot;  #版本&gt;services:#服务 服务01:web   build: .&#x2F;dir#服务配置   images 服务2:redis .... &gt;#其他配置  网络&#x2F;卷,全局规则&gt;networks:&gt;volumes:&gt;configs:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p><img src="/2020/03/18/docker/image-20210315162905221.png" alt="image-20210315162905221"></p><h3 id="部署练习"><a href="#部署练习" class="headerlink" title="部署练习"></a>部署练习</h3><h6 id="springboot-mysql的docker-compose文件"><a href="#springboot-mysql的docker-compose文件" class="headerlink" title="springboot+mysql的docker-compose文件"></a>springboot+mysql的docker-compose文件</h6><pre class="line-numbers language-none"><code class="language-none">version: &quot;2.3&quot;services:  mysql:    restart: always    image: mysql:8.0.15    container_name: mysql    security_opt:      - seccomp:unconfined    ports:      - 3306:3306    command: [        &#39;--default-authentication-plugin&#x3D;mysql_native_password&#39;,        #以下两项已在配置文件中设置        #&#39;--character-set-server&#x3D;utf8mb4&#39;,        #&#39;--collation-server&#x3D;utf8mb4_unicode_ci&#39;    ]    environment:      - &quot;TZ&#x3D;Asia&#x2F;Shanghai&quot;      - &quot;MYSQL_ROOT_HOST&#x3D;%&quot; #远程访问 MYSQL_ROOT_HOST: &#39;%&#39;      - &quot;MYSQL_ROOT_PASSWORD&#x3D;root&quot;      - &quot;MYSQL_DATABASE&#x3D;boot2020&quot;    volumes:      - .&#x2F;resources&#x2F;mysql&#x2F;database:&#x2F;var&#x2F;lib&#x2F;mysql      - .&#x2F;resources&#x2F;mysql&#x2F;conf&#x2F;my.cnf:&#x2F;etc&#x2F;my.cnf      #数据库还原目录 可将需要还原的sql文件放在这里      - .&#x2F;resources&#x2F;mysql:&#x2F;docker-entrypoint-initdb.d    user: root  sept:    build: .    image: webapp    ports:      - &quot;8080:8080&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="springboot-mysql的dockerfile文件"><a href="#springboot-mysql的dockerfile文件" class="headerlink" title="springboot+mysql的dockerfile文件"></a>springboot+mysql的dockerfile文件</h5><pre class="line-numbers language-none"><code class="language-none">FROM anapsix&#x2F;alpine-java:8_server-jre_unlimitedMAINTAINER wangzhongheng&lt;yaoqi@163.com&gt;ADD *.jar app.jarCMD [&quot;--server.port&#x3D;8080&quot;]EXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;, &quot;&#x2F;app.jar&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h3><h4 id="区分网卡-这里是阿里云服务器"><a href="#区分网卡-这里是阿里云服务器" class="headerlink" title="区分网卡(这里是阿里云服务器)"></a>区分网卡(这里是阿里云服务器)</h4><p><img src="/2020/03/18/docker/image-20210318170031883.png" alt="image-20210318170031883"></p><blockquote><p>lo:本机网卡</p><p>eth0:阿里云网卡</p><p>docker0网卡</p></blockquote><p>–link容器互通 :</p><h3 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h3><h6 id="清理Docker占用的磁盘空间，迁移-var-lib-docker-目录"><a href="#清理Docker占用的磁盘空间，迁移-var-lib-docker-目录" class="headerlink" title="清理Docker占用的磁盘空间，迁移 /var/lib/docker 目录"></a>清理Docker占用的磁盘空间，迁移 /var/lib/docker 目录</h6><blockquote><p><strong>docker system prune</strong> -a命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无tag的镜像)。</p><p><a href="https://blog.csdn.net/weixin_32820767/article/details/81196250">https://blog.csdn.net/weixin_32820767/article/details/81196250</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p><img src="/2020/03/18/docker/image-20210419151129044.png" alt="image-20210419151129044"></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离线安装使用Docker</title>
      <link href="2020/02/20/chi-xian-an-zhuang-shi-yong-docker/"/>
      <url>2020/02/20/chi-xian-an-zhuang-shi-yong-docker/</url>
      
        <content type="html"><![CDATA[<h2 id="1-下载镜像上传到服务器"><a href="#1-下载镜像上传到服务器" class="headerlink" title="1.下载镜像上传到服务器"></a>1.下载镜像上传到服务器</h2><blockquote><p>镜像站</p><p><a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a><br><a href="https://download.docker.com/linux/centos/8/x86_64/stable/Packages/">https://download.docker.com/linux/centos/8/x86_64/stable/Packages/</a></p></blockquote><h4 id="主要的三个包"><a href="#主要的三个包" class="headerlink" title="主要的三个包"></a>主要的三个包</h4><p>containerd.io 与操作系统API(在本例中是LXC - Linux Containers)进行接口，本质上将Docker与操作系统解耦，还为非Docker容器管理器提供了容器服务</p><p>Docker -ce - Docker守护进程，这是做所有管理工作的一部分，在Linux上需要另外两个</p><p>Docker -ce- cli- CLI工具来控制这个守护进程，如果你想控制一个远程的Docker守护进程，你可以自己安装它们</p><p>docker-compose  ompose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p><h2 id="2-安装rpm包"><a href="#2-安装rpm包" class="headerlink" title="2.安装rpm包"></a>2.安装rpm包</h2><p>2.1将docker的rpm包进行yum install 文件名命令进行安装依次顺序:ce ce-cli io</p><p>2.2.将docker-compose-Linux-x86_64设置为可执行文件(chmod +x docker-compose-Linux-x86_64),在将docker-compose-Linux-x86_64 拷贝到linxu目录(cp docker-compose-Linux-x86_64 /usr/local/bin/docker-compose)</p><h2 id="3-load-tar包为镜像执行compose命令"><a href="#3-load-tar包为镜像执行compose命令" class="headerlink" title="3.load tar包为镜像执行compose命令"></a>3.load tar包为镜像执行compose命令</h2><p>3.1 将tar包load成镜像 docker load -i eoms-state-grid.tar  或者 docker import centos_container.tar centos:latest</p><p>3.2  docker save -o 要保存的文件名  要保存的镜像名字</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识spring</title>
      <link href="2019/02/20/chu-shi-spring/"/>
      <url>2019/02/20/chu-shi-spring/</url>
      
        <content type="html"><![CDATA[<h1 id="一-Spring概述"><a href="#一-Spring概述" class="headerlink" title="一 Spring概述"></a>一 Spring概述</h1><h2 id="1-1-Spring是什么"><a href="#1-1-Spring是什么" class="headerlink" title="1.1 Spring是什么"></a>1.1 Spring是什么</h2><p>Spring是分层的 Java SE/EE应用 <strong>full-stack（全栈） 轻量级开源框架</strong>。</p><p>Spring的核心是 <strong>IOC</strong>（Inverse Of Control:控制反转）和 <strong>AOP</strong>（Aspect Oriented Programming:面向切面编程）</p><p>Spring一个全栈应用框架, 提供了表现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多应用技术</p><p>Spring还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架 </p><p>Spring官网：<a href="https://spring.io/">https://spring.io/</a></p><h2 id="1-2-Spring发展历程"><a href="#1-2-Spring发展历程" class="headerlink" title="1.2 Spring发展历程"></a>1.2 Spring发展历程</h2><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">* EJB1997 年，IBM提出了EJB 的思想    1998 年，SUN制定开发标准规范 EJB1.0    1999 年，EJB1.1 发布    2001 年，EJB2.0 发布    2003 年，EJB2.1 发布    2006 年，EJB3.0 发布    * SpringRod Johnson（ Spring 之父）改变Java世界的大师级人物    2002年编著《Expert one on one J2EE design and development》   指出了JavaEE和EJB组件框架中的存在的一些主要缺陷；提出普通java类依赖注入更为简单的解决方案。       2004年编著《Expert one-on-one J2EE Development without EJB》    阐述了JavaEE开发时不使用EJB的解决方式（Spring 雏形）    同年4月spring1.0诞生        2006年10月，发布 Spring2.02009年12月，发布 Spring3.02013年12月，发布 Spring4.0   2017年9月， 发布最新 Spring5.0 通用版（GA）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-Spring优势【学完八天再去读】"><a href="#1-3-Spring优势【学完八天再去读】" class="headerlink" title="1.3 Spring优势【学完八天再去读】"></a>1.3 Spring优势【学完八天再去读】</h2><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">1. 方便解耦，简化开发通过Spring提供的 IOC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度耦合。  用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。2. AOP编程的支持通过Spring的AOP功能，方便进行面向切面编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松实现。3. 声明式事务的支持可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务管理，提高开发效率和质量。4. 方便程序的测试可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。5. 方便集成各种优秀框架Spring对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的支持。6. 降低JavaEE API的使用难度Spring对JavaEEAPI（如JDBC、JavaMail、RPC等）进行了薄薄的封装层，使这些 API 的使用难度大为降低。7. Java源码经典学习范例Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java 设计模式灵活运用以及对 Java技术的高深造诣。它的源代码无意是 Java 技术的最佳实践的范例。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-Spring体系结构"><a href="#1-4-Spring体系结构" class="headerlink" title="1.4 Spring体系结构"></a>1.4 Spring体系结构</h2><p><img src="/2019/02/20/chu-shi-spring/image-20200528093016354.png" alt="image-20200528093016354">  </p><blockquote><p>spring全栈框架：web层、service层（方法增强、事务）、dao层都提供了解决方案…</p></blockquote><h1 id="二-初识IOC【理解】"><a href="#二-初识IOC【理解】" class="headerlink" title="二 初识IOC【理解】"></a>二 初识IOC【理解】</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p><strong>控制反转（Inverse Of Control）</strong>不是什么技术，而是一种设计思想。它的目的是指导我们设计出更加松耦合的程序。</p><blockquote><p>控制：在java中指的是对象的控制权限（创建、销毁）</p><p>反转：指的是对象控制权由原来 <strong>由开发者在类中手动控制</strong> 反转到 <strong>由Spring容器控制</strong></p></blockquote><p><strong>举个栗子</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">* 原来我们需要一个对象，需要自己手动new出来UserServletUserService us &#x3D; new UserServiceImpl();* 学习了spring之后，需要一个对象，从spring的ioc容器获取UserServletUserService us &#x3D; spring的IOC容器.getBean(&quot;userService&quot;);* IOC的核心思想：松耦合<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>需求</strong></p><p>​    实现service层与dao层代码解耦合</p><h2 id="2-2-环境搭建"><a href="#2-2-环境搭建" class="headerlink" title="2.2 环境搭建"></a>2.2 环境搭建</h2><h4 id="①-在idea创建一个-empty-project"><a href="#①-在idea创建一个-empty-project" class="headerlink" title="① 在idea创建一个 empty project"></a>① 在idea创建一个 empty project</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528093646068.png" alt="image-20200528093646068"> </p><p><img src="/2019/02/20/chu-shi-spring/image-20200528093705676.png" alt="image-20200528093705676"> </p><p><img src="/2019/02/20/chu-shi-spring/image-20200528093726404.png" alt="image-20200528093726404"> </p><p><img src="/2019/02/20/chu-shi-spring/image-20200528093752502.png" alt="image-20200528093752502"> </p><h4 id="②-创建maven的java模块"><a href="#②-创建maven的java模块" class="headerlink" title="② 创建maven的java模块"></a>② 创建maven的java模块</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528093922762.png" alt="image-20200528093922762"> </p><h4 id="③-导入jar包"><a href="#③-导入jar包" class="headerlink" title="③ 导入jar包"></a>③ 导入jar包</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--依赖管理--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--dom4j--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>dom4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>dom4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.6.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--xpath--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>jaxen<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jaxen<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--junit--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-版本一：原始版本"><a href="#2-3-版本一：原始版本" class="headerlink" title="2.3 版本一：原始版本"></a>2.3 版本一：原始版本</h2><h4 id="①-编写UserDao接口和实现类"><a href="#①-编写UserDao接口和实现类" class="headerlink" title="① 编写UserDao接口和实现类"></a>① 编写UserDao接口和实现类</h4><blockquote><p>快速创建  alt + insert</p></blockquote><p><img src="/2019/02/20/chu-shi-spring/image-20200528094345998.png" alt="image-20200528094345998"> </p><h4 id="②-编写UserService接口和实现类"><a href="#②-编写UserService接口和实现类" class="headerlink" title="② 编写UserService接口和实现类"></a>② 编写UserService接口和实现类</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528094450723.png" alt="image-20200528094450723"> </p><h4 id="③-编写UserTest"><a href="#③-编写UserTest" class="headerlink" title="③ 编写UserTest"></a>③ 编写UserTest</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528094637017.png" alt="image-20200528094637017"> </p><h4 id="④-问题"><a href="#④-问题" class="headerlink" title="④ 问题"></a>④ 问题</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528094856387.png" alt="image-20200528094856387"> </p><h2 id="2-4-版本二：工厂解耦"><a href="#2-4-版本二：工厂解耦" class="headerlink" title="2.4 版本二：工厂解耦"></a>2.4 版本二：工厂解耦</h2><blockquote><p>我们需要在项目中 定义BeanFactory + xml解析，实现各层代码之间解耦合</p></blockquote><h4 id="①-编写beans-xml"><a href="#①-编写beans-xml" class="headerlink" title="① 编写beans.xml"></a>① 编写beans.xml</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528095248553.png" alt="image-20200528095248553"> </p><h4 id="②-编写BeanFactory"><a href="#②-编写BeanFactory" class="headerlink" title="② 编写BeanFactory"></a>② 编写BeanFactory</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BeanFactory &#123;    public static Object getBean(String id) &#123;        Object object &#x3D; null;        try &#123;            &#x2F;&#x2F; 1.通过类加载器读取 beans.xml            InputStream in &#x3D; BeanFactory.class.getClassLoader().getResourceAsStream(&quot;beans.xml&quot;);            &#x2F;&#x2F; 2.创建dom4j核心解析器对象            SAXReader saxReader &#x3D; new SAXReader();            Document document &#x3D; saxReader.read(in);            &#x2F;&#x2F; 3.编写xpath表达式            &#x2F;&#x2F; String xpath &#x3D; &quot;&#x2F;&#x2F;bean[@id&#x3D;&#39;userDao&#39;]&quot;;            String xpath &#x3D; &quot;&#x2F;&#x2F;bean[@id&#x3D;&#39;&quot; + id + &quot;&#39;]&quot;;            &#x2F;&#x2F; 4.获取指定id的标签对象            Element element &#x3D; (Element) document.selectSingleNode(xpath);            &#x2F;&#x2F; 5.获取全限定名            String className &#x3D; element.attributeValue(&quot;class&quot;);            &#x2F;&#x2F; 6.通过反射创建对象实例            object &#x3D; Class.forName(className).newInstance();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F; 7.返回对象实例        return object;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="③-修改UserServiceImpl"><a href="#③-修改UserServiceImpl" class="headerlink" title="③ 修改UserServiceImpl"></a>③ 修改UserServiceImpl</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528100054073.png" alt="image-20200528100054073"> </p><h4 id="④-问题-1"><a href="#④-问题-1" class="headerlink" title="④ 问题"></a>④ 问题</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528100307180.png" alt="image-20200528100307180"> </p><h2 id="2-5-版本三：工厂优化"><a href="#2-5-版本三：工厂优化" class="headerlink" title="2.5 版本三：工厂优化"></a>2.5 版本三：工厂优化</h2><blockquote><p>我们可以使用单例模式</p></blockquote><h4 id="①-修改BeanFactory"><a href="#①-修改BeanFactory" class="headerlink" title="① 修改BeanFactory"></a>① 修改BeanFactory</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BeanFactory &#123;    &#x2F;&#x2F; 声明存储对象的容器（map集合）    private static Map&lt;String, Object&gt; ioc &#x3D; new HashMap&lt;&gt;();    &#x2F;&#x2F; 静态代码块，初始化ioc容器    static &#123;        String id &#x3D; null;        String className &#x3D; null;        Object object &#x3D; null;        try &#123;            &#x2F;&#x2F; 1.通过类加载器读取 beans.xml            InputStream in &#x3D; BeanFactory.class.getClassLoader().getResourceAsStream(&quot;beans.xml&quot;);            &#x2F;&#x2F; 2.创建dom4j核心解析器对象            SAXReader saxReader &#x3D; new SAXReader();            Document document &#x3D; saxReader.read(in);            &#x2F;&#x2F; 3.编写xpath表达式            String xpath &#x3D; &quot;&#x2F;&#x2F;bean&quot;;            &#x2F;&#x2F; 4.获取所有的bean标签对象            List&lt;Element&gt; list &#x3D; document.selectNodes(xpath);            &#x2F;&#x2F; 5.遍历集合，创建对象实例，设置到ioc容器中            for (Element element : list) &#123;                id &#x3D; element.attributeValue(&quot;id&quot;);                className &#x3D; element.attributeValue(&quot;class&quot;);                object &#x3D; Class.forName(className).newInstance();                &#x2F;&#x2F; 设置到map集合                ioc.put(id, object);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    &#x2F;&#x2F; 从ioc容器中获取指定id的对象实例    public static Object getBean(String id) &#123;        return ioc.get(id);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h2><p>​    对象的创建由原来的 使用 <strong>new关键字在类中主动创建</strong> 变成了 <strong>从工厂中获取</strong>,  而对象的创建过程由工厂内部来实现, 而这个工厂就是 <strong>Spring的IOC容器</strong>,  也就是以后我们的对象不再自己创建,而是直接向Spring要, 这种思想就是<strong>IOC</strong></p><blockquote><p>ioc目的：松耦合…，你可以简单的认为就是一个map集合（ioc容器）</p></blockquote><h1 id="三-Spring快速入门【重点】"><a href="#三-Spring快速入门【重点】" class="headerlink" title="三 Spring快速入门【重点】"></a>三 Spring快速入门【重点】</h1><h2 id="3-1-需求"><a href="#3-1-需求" class="headerlink" title="3.1 需求"></a>3.1 需求</h2><p><img src="/2019/02/20/chu-shi-spring/1572949001370.png" alt="1572949001370"> </p><h2 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h2><h4 id="①-创建maven的java模块"><a href="#①-创建maven的java模块" class="headerlink" title="① 创建maven的java模块"></a>① 创建maven的java模块</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528103111181.png" alt="image-20200528103111181"> </p><h4 id="②-导入spring相关坐标"><a href="#②-导入spring相关坐标" class="headerlink" title="② 导入spring相关坐标"></a>② 导入spring相关坐标</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--依赖管理--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--spring的核心坐标--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--junit--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/02/20/chu-shi-spring/image-20200528103318683.png" alt="image-20200528103318683"> </p><h4 id="③-编写UserDao接口和实现类"><a href="#③-编写UserDao接口和实现类" class="headerlink" title="③ 编写UserDao接口和实现类"></a>③ 编写UserDao接口和实现类</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528103407104.png" alt="image-20200528103407104"> </p><h4 id="④-创建spring的核心配置文件，导入约束"><a href="#④-创建spring的核心配置文件，导入约束" class="headerlink" title="④ 创建spring的核心配置文件，导入约束"></a>④ 创建spring的核心配置文件，导入约束</h4><blockquote><p>官方推荐：applicationContext.xml</p></blockquote><p><img src="/2019/02/20/chu-shi-spring/image-20200528103604814.png" alt="image-20200528103604814"> </p><h4 id="⑤-编写bean标签（id、class）"><a href="#⑤-编写bean标签（id、class）" class="headerlink" title="⑤ 编写bean标签（id、class）"></a>⑤ 编写bean标签（id、class）</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528103739341.png" alt="image-20200528103739341"> </p><h4 id="⑥-测试（模拟service层）"><a href="#⑥-测试（模拟service层）" class="headerlink" title="⑥ 测试（模拟service层）"></a>⑥ 测试（模拟service层）</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserTest &#123;    &#x2F;&#x2F; spring的快速入门    @Test    public void test01() throws Exception &#123;        &#x2F;&#x2F; 1.通过spring的api读取配置文件        ClassPathXmlApplicationContext app &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        &#x2F;&#x2F; 2.获取指定id的对象实例        UserDao userDao &#x3D; (UserDao) app.getBean(&quot;userDao&quot;);        userDao.save();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四-Spring相关API"><a href="#四-Spring相关API" class="headerlink" title="四 Spring相关API"></a>四 Spring相关API</h1><p>Spring的API体系非常庞大，这里我们先来介绍核心的内容</p><p><img src="/2019/02/20/chu-shi-spring/image-20200528104906116.png" alt="image-20200528104906116"> </p><h2 id="4-1-二个接口"><a href="#4-1-二个接口" class="headerlink" title="4.1 二个接口"></a>4.1 二个接口</h2><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">* BeanFactory介绍：这是IOC容器的顶级接口 它定义了IOC的最基础的功能, 但是其功能比较简单,一般面向Spring自身使用特点：在第一次使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化[用的时候再创建]懒汉设计* ApplicationContext介绍：这是在BeanFactory基础上衍生出的接口,它扩展了BeanFactory的功能,一般面向程序员使用特点：在容器启动时，一次性创建并加载了所有的Bean  [初始化的时候全创建好]恶汉设计* 小结：上面两种方式创建的对象都是单例, 只是创建对象的时机不同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-三个实现类"><a href="#4-2-三个实现类" class="headerlink" title="4.2 三个实现类"></a>4.2 三个实现类</h2><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">* ClassPathXmlApplicationContext功能：读取类路径（classpath）下的xml配置文件* FileSystemXmlApplicationContext功能：读取本地磁盘下的xml配置文件* AnnotationConfigApplicationContext功能：读取java配置类加载配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/02/20/chu-shi-spring/image-20200528105646306.png" alt="image-20200528105646306"> </p><h2 id="4-3-一个方法"><a href="#4-3-一个方法" class="headerlink" title="4.3 一个方法"></a>4.3 一个方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">* public Object getBean(String name) throws BeansException;功能：通过指定id获取对象的实例，需要手动强转* public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType);功能：通过指定类型获取对象的实例，不需要强转* public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType);功能：通过指定id和类型获取对象的实例<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; getBean方法介绍@Testpublic void test02() throws Exception &#123;    &#x2F;&#x2F; 1.通过spring的api读取配置文件    ApplicationContext app &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);    &#x2F;&#x2F; 方式一： 通过指定id获取对象的实例，需要手动强转    &#x2F;*         UserDao userDao1 &#x3D; (UserDao) app.getBean(&quot;userDao&quot;);        userDao1.save();    *&#x2F;    &#x2F;&#x2F; 方式二：通过指定（接口）类型获取对象的实例，不需要强转    &#x2F;*            缺点：如果同一个接口类型下有多个对象实例，会报错的...            UserDao userDao2 &#x3D; app.getBean(UserDao.class);            userDao2.save();    *&#x2F;    &#x2F;&#x2F; 方式三：通过指定id和类型获取对象的实例    UserDao userDao3 &#x3D; app.getBean(&quot;userDao&quot;, UserDao.class);    userDao3.save();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/02/20/chu-shi-spring/image-20200528110958697.png" alt="image-20200528110958697"> </p><h2 id="4-4-知识小结"><a href="#4-4-知识小结" class="headerlink" title="4.4 知识小结"></a>4.4 知识小结</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">ApplicationContext app &#x3D; new ClasspathXmlApplicationContext(&quot;xml文件&quot;);    app.getBean(&quot;id&quot;);app.getBean(Class);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="五-Spring配置文件"><a href="#五-Spring配置文件" class="headerlink" title="五 Spring配置文件"></a>五 Spring配置文件</h1><h2 id="5-1-Bean标签基本配置"><a href="#5-1-Bean标签基本配置" class="headerlink" title="5.1 Bean标签基本配置"></a>5.1 Bean标签基本配置</h2><h4 id="①-基本配置"><a href="#①-基本配置" class="headerlink" title="① 基本配置"></a>① 基本配置</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--    bean标签的二个基本属性        id：在ioc容器的唯一标识        class：创建对象实例的全限定名--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cn.itcast.dao.impl.UserDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="②-作用范围"><a href="#②-作用范围" class="headerlink" title="② 作用范围"></a>② 作用范围</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--    bean标签还有一个属性scope属性：声明此对象的作用范围        singleton：单例对象（默认）            何时创建？                ioc容器初始化时，创建对象            对象运行？                只要ioc容器在，对象就一直活着....            何时销毁？                ioc容器关闭时，销毁对象        prototype：多例对象            何时创建？                在调用getBean()方法时，创建            对象运行？                一直使用就一直活着            何时销毁？                当对象不再使用后，根据JVM GC机制垃圾回收--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cn.itcast.dao.impl.UserDaoImpl<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prototype<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="③-生命周期"><a href="#③-生命周期" class="headerlink" title="③ 生命周期"></a>③ 生命周期</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528113212187.png" alt="image-20200528113212187"> </p><p><img src="/2019/02/20/chu-shi-spring/image-20200528113642961.png" alt="image-20200528113642961"> </p><h2 id="5-2-spring创建对象实例三种方式"><a href="#5-2-spring创建对象实例三种方式" class="headerlink" title="5.2 spring创建对象实例三种方式"></a>5.2 spring创建对象实例三种方式</h2><h4 id="①-无参构造方法实例化【重点】"><a href="#①-无参构造方法实例化【重点】" class="headerlink" title="① 无参构造方法实例化【重点】"></a>① 无参构造方法实例化【重点】</h4><blockquote><p>在企业开发时，所有的类必须提供无参构造方法…</p></blockquote><p><img src="/2019/02/20/chu-shi-spring/image-20200528114052816.png" alt="image-20200528114052816"> </p><h4 id="②-工厂静态方法实例化【了解】"><a href="#②-工厂静态方法实例化【了解】" class="headerlink" title="② 工厂静态方法实例化【了解】"></a>② 工厂静态方法实例化【了解】</h4><blockquote><p>​    依赖的jar包中有个A类，A类中有个静态方法m1，m1方法的返回值是一个B对象。如果我们频繁使用B对象，此时我们可以将B对象的创建权交给spring的IOC容器，以后我们在使用B对象时，无需调用A类中的m1方法，直接从IOC容器获得。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*    工厂静态方法实例化对象 *&#x2F;public class StaticFactoryBean &#123;    public static UserDao createUserDao() &#123;        return new UserDaoImpl();    &#125;    &#x2F;&#x2F; 传统方式，自己通过工厂获取对象...    public static void main(String[] args) &#123;        UserDao userDao &#x3D; StaticFactoryBean.createUserDao();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/02/20/chu-shi-spring/image-20200528114853315.png" alt="image-20200528114853315"> </p><h4 id="③-工厂普通方法实例化【了解】"><a href="#③-工厂普通方法实例化【了解】" class="headerlink" title="③ 工厂普通方法实例化【了解】"></a>③ 工厂普通方法实例化【了解】</h4><blockquote><p>​    依赖的jar包中有个A类，A类中有个普通方法m1，m1方法的返回值是一个B对象。如果我们频繁使用B对象，此时我们可以将B对象的创建权交给spring的IOC容器，以后我们在使用B对象时，无需调用A类中的m1方法，直接从IOC容器获得。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*    工厂普通方法实例化对象 *&#x2F;public class DynamicFactoryBean &#123;    public UserDao createUserDao() &#123;        return new UserDaoImpl();    &#125;    &#x2F;&#x2F; 传统方式，自己通过工厂获取对象...    public static void main(String[] args) &#123;        &#x2F;&#x2F; 1.创建工厂对象        DynamicFactoryBean dynamicFactoryBean &#x3D; new DynamicFactoryBean();        &#x2F;&#x2F; 2.创建UserDao对象        UserDao userDao &#x3D; dynamicFactoryBean.createUserDao();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2019/02/20/chu-shi-spring/image-20200528115548165.png" alt="image-20200528115548165"> </p><h2 id="5-5-Bean依赖注入【重点】"><a href="#5-5-Bean依赖注入【重点】" class="headerlink" title="5.5 Bean依赖注入【重点】"></a>5.5 Bean依赖注入【重点】</h2><h3 id="5-5-1-概述"><a href="#5-5-1-概述" class="headerlink" title="5.5.1 概述"></a>5.5.1 概述</h3><p><strong>依赖注入(Dependency Injection, DI)</strong> 它是 Spring 框架核心 IOC 的具体实现</p><p>其实就是给对象中的属性赋值的过程，通过spring完成依赖注入</p><p><img src="/2019/02/20/chu-shi-spring/image-20200528120207319.png" alt="image-20200528120207319"> </p><h3 id="5-5-2-环境搭建"><a href="#5-5-2-环境搭建" class="headerlink" title="5.5.2 环境搭建"></a>5.5.2 环境搭建</h3><h4 id="①-创建maven的java模块-1"><a href="#①-创建maven的java模块-1" class="headerlink" title="① 创建maven的java模块"></a>① 创建maven的java模块</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528140940389.png" alt="image-20200528140940389"> </p><h4 id="②-复制UserDao"><a href="#②-复制UserDao" class="headerlink" title="② 复制UserDao"></a>② 复制UserDao</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528141025013.png" alt="image-20200528141025013"> </p><h4 id="③-复制UserService"><a href="#③-复制UserService" class="headerlink" title="③ 复制UserService"></a>③ 复制UserService</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528141124936.png" alt="image-20200528141124936"> </p><h4 id="④-编写spring的核心配置文件"><a href="#④-编写spring的核心配置文件" class="headerlink" title="④ 编写spring的核心配置文件"></a>④ 编写spring的核心配置文件</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>        http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--将userDao交给ioc容器--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cn.itcast.dao.impl.UserDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--将userService交给ioc容器--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cn.itcast.service.impl.UserServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="⑤-测试【肯定报错】"><a href="#⑤-测试【肯定报错】" class="headerlink" title="⑤ 测试【肯定报错】"></a>⑤ 测试【肯定报错】</h4><blockquote><p>service依赖了dao，但是缺少依赖注入环境</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserTest &#123;    @Test    public void test01() throws Exception &#123;        &#x2F;&#x2F; 1.加载spring配置文件        ClassPathXmlApplicationContext app &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        &#x2F;&#x2F; 2.获取service对象实例        UserService userService &#x3D; app.getBean(UserService.class);        userService.save();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-6-Bean依赖注入方式"><a href="#5-6-Bean依赖注入方式" class="headerlink" title="5.6 Bean依赖注入方式"></a>5.6 Bean依赖注入方式</h2><h4 id="①-构造方法"><a href="#①-构造方法" class="headerlink" title="① 构造方法"></a>① 构造方法</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528142641032.png" alt="image-20200528142641032"> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserServiceImpl implements UserService &#123;    private UserDao userDao;    public UserServiceImpl(UserDao userDao) &#123;        this.userDao &#x3D; userDao;    &#125;    @Override    public void save() &#123;        userDao.save();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--    构造方法注入： &lt;constructor-arg> 子标签        版本一：            name：构造方法参数名称            value：简单数据类型（String、int、double...）            ref：引用数据类型（从ioc容器中获取的对象）        版本二：            index：构造方法参数索引            type：该索引对应的java类型（全限定名）            value：简单数据类型（String、int、double...）            ref：引用数据类型（从ioc容器中获取的对象）--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cn.itcast.service.impl.UserServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!--&lt;constructor-arg index="0" type="cn.itcast.dao.UserDao"  ref="userDao">&lt;/constructor-arg>--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="②-set方法【重点】"><a href="#②-set方法【重点】" class="headerlink" title="② set方法【重点】"></a>② set方法【重点】</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528143450506.png" alt="image-20200528143450506"> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserServiceImpl implements UserService &#123;    private UserDao userDao;    public void setUserDao(UserDao userDao) &#123;        this.userDao &#x3D; userDao;    &#125;    @Override    public void save() &#123;        userDao.save();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--将userDao交给ioc容器--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cn.itcast.dao.impl.UserDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>  <span class="token comment">&lt;!--        set方法注入：&lt;property> 子标签            name：set方法的属性名  setUserDao()  -> UserDao -> userDao            value：简单数据类型（String、int、double...）            ref：引用数据类型（从ioc容器中获取的对象）--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cn.itcast.service.impl.UserServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="③-P命名空间注入"><a href="#③-P命名空间注入" class="headerlink" title="③ P命名空间注入"></a>③ P命名空间注入</h4><blockquote><p>P命名空间注入底层（本质）使用的也是set方法注入，只是在上着的基础上进行简化</p></blockquote><p><strong>1）导入P命名空间约束</strong></p><p><img src="/2019/02/20/chu-shi-spring/image-20200528143931258.png" alt="image-20200528143931258"> </p><p><strong>2）使用P命名空间注完成注入</strong></p><p><img src="/2019/02/20/chu-shi-spring/image-20200528144056138.png" alt="image-20200528144056138"> </p><h2 id="5-7-Bean依赖注入的数据类型"><a href="#5-7-Bean依赖注入的数据类型" class="headerlink" title="5.7 Bean依赖注入的数据类型"></a>5.7 Bean依赖注入的数据类型</h2><h4 id="①-简单数据类型"><a href="#①-简单数据类型" class="headerlink" title="① 简单数据类型"></a>① 简单数据类型</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528144732571.png" alt="image-20200528144732571"> </p><h4 id="②-引用数据类型"><a href="#②-引用数据类型" class="headerlink" title="② 引用数据类型"></a>② 引用数据类型</h4><blockquote><p>【参考刚才讲的依赖注入三种方式】</p></blockquote><h4 id="③-集合数据类型"><a href="#③-集合数据类型" class="headerlink" title="③ 集合数据类型"></a>③ 集合数据类型</h4><h5 id="1-单列集合"><a href="#1-单列集合" class="headerlink" title="1) 单列集合"></a>1) 单列集合</h5><blockquote><p>list、set、array</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserDaoImpl implements UserDao &#123;    private List&lt;Object&gt; list;    private Set&lt;Object&gt; set;    private Object[] array;    public void setList(List&lt;Object&gt; list) &#123;        this.list &#x3D; list;    &#125;    public void setSet(Set&lt;Object&gt; set) &#123;        this.set &#x3D; set;    &#125;    public void setArray(Object[] array) &#123;        this.array &#x3D; array;    &#125;    @Override    public void save() &#123;        System.out.println(&quot;UserDao保存了....&quot;);        System.out.println(list);        System.out.println(set);        System.out.println(Arrays.toString(array));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--    di 注入单列集合类型        需要在 &lt;property>标签中            list集合  使用子标签  &lt;list>                &lt;value> 简单数据类型                &lt;ref>   引用数据类型（对象在ioc容器中）          set集合    使用子标签 &lt;set>                &lt;value> 简单数据类型                &lt;ref>   引用数据类型（对象在ioc容器中）         array数组   使用子标签&lt;array>                &lt;value> 简单数据类型                &lt;ref>   引用数据类型（对象在ioc容器中）--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cn.itcast.dao.impl.UserDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>石榴姐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>冬香<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>set<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>秋香<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>马冬梅<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>array<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>array</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>国际峰<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>小绵羊<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span> <span class="token attr-name">bean</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>array</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2）双列集合"><a href="#2）双列集合" class="headerlink" title="2）双列集合"></a>2）双列集合</h5><blockquote><p>map、properties</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UserDaoImpl implements UserDao &#123;    private Map&lt;String, Object&gt; map;    private Properties props;    public void setMap(Map&lt;String, Object&gt; map) &#123;        this.map &#x3D; map;    &#125;    public void setProps(Properties props) &#123;        this.props &#x3D; props;    &#125;    @Override    public void save() &#123;        System.out.println(&quot;UserDao保存了....&quot;);        System.out.println(map);        System.out.println(props);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--           di 注入双列集合类型              需要在 &lt;property>标签中                map集合 使用子标签&lt;map>                     &lt;entry key="" value="简单数据类型"  |  value-ref="引用数据类型（对象ioc中）"  >&lt;/entry>               properties集合 使用子标签 &lt;props>                     &lt;prop key="" >value&lt;/prop>    --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>userDao<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cn.itcast.dao.impl.UserDaoImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>k1<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>v1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>k2<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>v2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>u1<span class="token punctuation">"</span></span> <span class="token attr-name">value-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>props<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>props</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>k1<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>v1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>k2<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>v2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>k3<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>v3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>props</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-8-配置文件模块化"><a href="#5-8-配置文件模块化" class="headerlink" title="5.8 配置文件模块化"></a>5.8 配置文件模块化</h2><p>​    实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，也就是所谓的配置文件模块化。</p><h4 id="①-并列加载"><a href="#①-并列加载" class="headerlink" title="① 并列加载"></a>① 并列加载</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528151905720.png" alt="image-20200528151905720"> </p><h4 id="②-主从配置【重点】"><a href="#②-主从配置【重点】" class="headerlink" title="② 主从配置【重点】"></a>② 主从配置【重点】</h4><p><img src="/2019/02/20/chu-shi-spring/image-20200528152256268.png" alt="image-20200528152256268"> </p><blockquote><p>注意：</p><p>1.在同一个xml中 bean标签的 id不能重复….</p><p>2.在多个模块中的xml中，bean标签id重复虽然不会报错，但是后加载的会覆盖先加载的….</p></blockquote><p>给我记住一句话，在开发中绝不允许出现重名的id</p><h2 id="5-9-知识小结"><a href="#5-9-知识小结" class="headerlink" title="5.9 知识小结"></a>5.9 知识小结</h2><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">&lt;bean&gt;标签：创建对象并放到spring的IOC容器    id属性:在容器中Bean实例的唯一标识，不允许重复    class属性:要实例化的Bean的全限定名    scope属性:Bean的作用范围，常用是Singleton(默认)和prototype    &lt;constructor-arg&gt;标签：属性注入name属性：属性名称    value属性：注入的简单属性值    ref属性：注入的对象引用值&lt;property&gt;标签：属性注入    name属性：属性名称    value属性：注入的简单属性值    ref属性：注入的对象引用值&lt;list&gt;    &lt;set&gt;    &lt;array&gt;    &lt;map&gt;    &lt;props&gt;&lt;import&gt;标签:导入其他的Spring的分文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
